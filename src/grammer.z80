;Grammer
;================:
;\\     /\       :
; \\   //\\      :
;  \\ //  \\     :
;   \\/----\\    :
;   //\----//\   :
;  // \\  // \\  :
; //   \\//   \\ :
;//     \/     \\:
;================:
;Project.........Grammer
;Program.........Grammer
;Author..........Zeda Elnara (ThunderBolt)
;E-mail..........xedaelnara@gmail.com
;Size............
;Language........English
;Programming.....Assembly
;Version.........V2Ac.14.5.16
;Last Update.....6:45 AM 5/22/2012 ;not now

#define bcall(x) rst 28h \ .dw x
#define LCDDelay()   in a,(16) \ rla \ jr c,$-3
;#define rotatemask() sla c \ jr nc,$+4 \ set 2,c    ;ld a,c \ cp $C0 \ rra \ ld c,a
#include "grammer.inc"
#define Coord(y,x)     .db 01,y,x
#define SHELL_BROKEN
#define speed
;for x,y,$ffff never stops
;Sqrt:' 255->0 Error
;"Rect(" is sometimes Line(
#define K_DELAY_DEFAULT 13
#define K_DELAY_ACCEL 3
#define ALIGN_COMMAND_TABLE
;#define include_fire
;#define include_prime
;#define include_ncr
;#define include_LoadTSA
;#define include_interrupt

.org $4000
.db $80,$0F, 0,0,0,0
.db $80,$12, $01,$04    ;signing key ID
.db $80,$47, "Grammer" ;change the $47 according to name len.
.db $80,$81, 1          ;num pages
.db $80,$90             ;no splash
.db $03,$22,$09,$00     ;date stamp
.db $02,$00             ;date stamp signature
.db $80,$70             ;final field

     jp main
jumptable:
#include "jmptable.z80"
#ifdef include_interrupt
.echo "  ",$4100-$," bytes before interrupt jump"
#if $4100<$
;need to shorten interrupt, possibly put in a jp instead of actual code
.echo "Alert!!! Interrupt table is in the wrong place!"
.echo "no interrupt table"
#else
.fill $4100-$,255
.fill $4201-$,$81
#endif
#endif

SelectedProg:

  ld de,OP1
  ld hl,OP5
  call mov9
SelectedProgOP1:
  ld hl,gbuf
  ld (BufPtr),hl
  bcall(_ChkFindSym)
  ret c
  ld hl,cmdShadow+2
  ld a,$BB
  cp (hl)
  jr nz,+_
  inc l
  ld a,$6D
  cp (hl)
  jp z,EndHook_prepush
_:
  ld a,(TempWord3)
  or a
  jp z,ExecOP1
;Here we need to move the code to RAM.
;  We will perform some minor pre-compiling
;  Currently it is just:
;     Convert numbers to raw binary
#include "precompile.z80"
  jr ExecOP1
ProgramAccessStart:
  bcall(_RclAns)
  sub 4
  jr nz,grazh
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld de,OP1
  ldir
  ld (de),a
ExecOP1:
  ld hl,OP1
  ld de,basic_prog
  call mov9
  bcall(_ChkFindSym)
  ld a,b
  ret c
  or a \ ret nz
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
parse_via_ptr:
;HL points to code
;BC is the size
  ld (parsePtr),hl
  ld (progStart),hl
  add hl,bc
  ld (progEnd),hl
  ld h,a \ ld l,a
  ld (parseError),hl
grazh:
#ifdef include_interrupt
  di
  ld a,11
  out (3),a
  ld a,6
  out (4),a   ;set slowest hardware timer mode
  ld a,41h
  ld i,a
  im 2
  ei
#endif
  call SetUpData
  call progmeta
  ld hl,BreakProgram
  push hl
ParserNext:
  bit IntActiveFlag,(iy+InternalFlag)
  jr nz,NoInt
  ld hl,(IntLoc)
  ld a,h \ or l
  jr z,NoInt
  ex de,hl
  ld hl,(IntCount)
  dec l
#ifdef include_fire
  jr nz,NoFire
  dec h
  jr nz,NoFire
  ld hl,(parsePtr)
  push hl
  ld (parsePtr),de
  set IntActiveFlag,(iy+InternalFlag)
  push bc
  call ParserNext
  pop bc
  pop hl
  ld (parsePtr),hl
  ld hl,(IntMax)
NoFire:
  ld (IntCount),hl
  res IntActiveFlag,(iy+InternalFlag)
#endif
NoInt:
  bit OnBlockFlag,(iy+UserFlags)
  call z,CheckStatus
  call z,ONErr
  ld de,ParserNext
  push de
ParseArg:
  ld hl,(BufPtr)        ;wtf is going on here?
  ld (gbuf_temp),hl
  ld hl,(parsePtr)
ParseArg2:
  bit IntActiveFlag,(iy+InternalFlag)
  jr nz,+_
  ei
_:
  ld a,(hl)
  inc hl
  ld (parsePtr),hl
#if (CommandJumpTable&255)=0
  ld h,CommandJumpTable>>8
  add a,a
  ld l,a
  rra
  jr nc,+_
  inc h
_:
#else
  ld e,a
  ld hl,CommandJumpTable
  ld d,0
  add hl,de
  add hl,de
#endif
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  ld hl,(parsePtr)
  ret
#ifdef include_prime
FracToken:
  ld h,b \ ld l,c
  call PrimeTest
  ld b,0
  ld (ThetaPrimeVar),bc
  ld b,h \ ld c,l
  ret
#endif
OutputToken:
  ld a,(hl)
  cp 11
  jr nz,+_
  call ParseNextFullArg
  ld a,c
  ld (OutputLogic),a
  ret
_:
  call ParseFullArg
  ld de,GrayRotate
  ex de,hl
  ld a,%11100111
  and (hl)
  ld (hl),a
  ld a,c
  and 3
  bit 0,a
  ld bc,vFont
  jr nz,+_
  ld bc,FontSet
_:
  rlca
  rlca \ rlca
  or (hl)
  ld (hl),a
  ld a,(de)
  cp 2Bh \ call z,ParseNextFullArg
  ld (FontPointer),bc
  ret
#include "commandtable.z80"
NewLine:
  ld (Ans),bc
IncPtr:
Ret:
  ret

augment:
  call ParseFullArg
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMem
  push de
  call ParseNextFullArg
  push bc
  ld hl,(parsePtr)
  inc hl
  ld (parsePtr),hl
  call GetVarInfo
  jp c,Pop2Exit
  or a \ jp nz,Pop2Exit
  ld hl,(parsePtr)
  ld (parsePtr),hl
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl)
  ld (TempWord1),hl
  pop de \ pop hl
InsertData:
  push hl
  add hl,bc
  ld b,h \ ld c,l
  ld hl,(TempWord1)
  ld (hl),b \ dec hl
  ld (hl),c \ inc hl \ inc hl
  add hl,de
  pop de
;hl points to where to insert data
;de is the number of bytes to insert
  push de \ push hl
  ld a,h \ or l
  jr z,+_
  ex de,hl
  bcall(_InsertMem)
_:
  ld hl,(parsePtr)
  ld (parsePtr),hl
  pop hl \ pop bc
  ld d,h \ ld e,l
  jp ZeroMem
PtChange:
  call ParseFullArg       ;To get the tilemap routine correct
  call ParseNextFullArg   ;Map Data
  push bc
  call ParseNextFullArg   ;Tile Data
  push bc
  call ParseNextFullArg   ;MapWidth
  push bc
  call ParseNextFullArg   ;MapX offset
  ld (TempWord2),bc
  call ParseNextFullArg   ;MapY offset
  ld (TempWord3),bc
  call ParseNextFullArg   ;Sprite Method
  push bc
  ld bc,(BufPtr)
  ld (TempWord5),bc
  cp 2Bh
  call z,ParseNextFullArg
  ld (BufPtr),bc
  pop bc
  ld a,c
  pop hl
  pop bc
  pop de
  call TileMap1
  ld hl,(TempWord5)
  ld (BufPtr),hl
  ret
solveSet:
  ld a,(hl) \ inc hl \ ld (parsePtr),hl
  sub 30h \ ld b,a
  ld a,(hl)
  jr nz,CopyDataUp
  inc hl \ ld (parsePtr),hl
  call GetVarInfo2 \ ret c
  push af \ push hl \ push bc
  ld hl,(parsePtr)
  inc hl \ ld (parsePtr),hl
  call GetVarInfo
  jr c,+_
  bcall(_DelVarArc)
_:
  ld hl,(parsePtr)
  ld a,2Bh \ cp (hl)
  pop bc
  call z,ParseNextFullArg
  push bc
  ld bc,0
  ld a,(hl)
  cp 2Bh  ;,
  call z,ParseNextFullArg
  pop de \ pop hl
  add hl,bc \ push hl
  push de
  ex de,hl


  ld a,(OP1)
  and $1F
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
  bcall(_CreateVar)
  inc de \ inc de
  pop bc \ pop hl \ pop af
  push de \ push bc
  call TSA
  pop hl \ ld (ThetaPrimeVar),hl
  pop bc \ ret
CopyDataUp:
  djnz CopyDataDown
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de \ pop hl
  ldir
  pop bc
  ret
CopyDataDown:
  djnz ErrorHandle
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de \ pop hl
  lddr
  pop bc
  ret
ErrorHandle:
  djnz CallError
  call ParseNextFullArg
  ld (ParseError),bc
  ret
CallError:
  djnz WritePort
  call ParseNextFullArg
  ld a,c
  cp 2
  jr nz,HandleError
  call ParseNextFullArg
  ld h,b \ ld l,c
  call GetGrammerText
  ld hl,13
  or a
  sbc hl,bc
  jr nc,+_
CustomError:
  ld bc,13
_:
  ex de,hl
  ld de,appErr1
  ldir
  xor a
  ld (de),a
  ld a,2
HandleError:
  jp GramHandl
WritePort:
  djnz ReadPort
  call ParseNextFullArg
  push bc
  ld c,0
  cp 2Bh
  call z,ParseNextFullArg
  pop de
  out (c),e
  ret
ReadPort:
  djnz +_
  ld c,0
  cp 2Bh
  call z,ParseNextFullArg
  in c,(c)
  ld b,0
  ret
_:
  djnz +_
  call ParseNextFullArg
  ld d,b
  ld e,c
  ld hl,smallEditRAM
  jr L46be
_:
  djnz EndSolveSet
  call ParseNextFullArg
  ld h,b
  ld l,c
  ld de,smallEditRAM
L46be:
  ld bc,108    ;=108, 2*54, 4*(26+1) ; could use 'call mov4 \ jp mov104's
ReadRAM:
  ldir
EndSolveSet:
  ret
ISToken:
  ld a,(hl) \ inc hl
  call VarP
  ret nc
  ld (parsePtr),de
g_ReadByte:
  ld e,(hl) \ inc (hl) \ inc hl \ ld d,(hl)
  jr nz,+_
  inc (hl)
_:
  ex de,hl
  ld c,(hl)
  ld b,0
  dec de
  ex de,hl
  ret
AnsToken:
  ld bc,(Ans) \ ret
#include "cmd/input.z80"
seqToken:
CopyHex:
  ex de,hl
  ld h,b \ ld l,c
_:
  call PutHexFromDE
  jr z,+_
  call PutHexFromDE
  inc hl
  jr nz,-_
  dec hl
  xor a
  rld
_:
  ld (parsePtr),de
  ld b,h \ ld c,l
  ret
PutHexFromDE:
  inc de
  ld a,(de)
  cp 3Fh
  ret z
  cp 3Ah
  jr c,+_
  sub 7
_:
  rld
  ret
SetData:
;[
  ld a,(hl)
  cp 16
  jr z,CopyHex      ;[(
  cp 6
  jr z,+_           ;[[
  dec hl
  ld (parsePtr),hl
  scf
_:
  sbc a,a
  ld e,a
  ld h,b \ ld l,c

SetData_loop:
  push hl
  push de
  call ParseNextFullArg
  pop de
  rlc e
  jr nc,+_
  dec hl
  ld a,(hl)
  cp 11
  inc hl
_:
  ld a,(hl)
  pop hl
  ld (hl),c \ inc hl
  jr nz,+_
  ld (hl),b \ inc hl
_:
  cp 2Bh
  jr z,SetData_loop
  ld b,h
  ld c,l
  ret
VarName:
   ld e,a
   ld d,(hl)
   inc d
   call GetNextVarNum
   dec d
   ld (parsePtr),hl
   ld (OP1+1),de
   xor a \ ld (OP1+3),a    ;I don't think this is necessary
   rst rFindSym
   jp VarTokenStepIn
FuncToken:
  call ParseFullArg
  ld (IntLoc),bc
  ld bc,80h
  cp 2Bh
  call z,ParseNextFullArg
  dec bc \ inc b \ inc c
  ld (IntMax),bc
  ld (IntCount),bc
  ret
SendToken:
  ld a,(hl)
  cp $AE
  jr nz,NotSendByte
;timer,byte
;success or fail
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  jp SendByte
NotSendByte:
  call ParseFullArg
  push bc               ;Size of the var
  inc hl \ ld (parsePtr),hl
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
  pop hl
  jr nc,+_
  ld a,(OP1)
  and 1fh
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
  push hl
  bcall(_CreateVar)
  pop bc
  ld a,b
  or c
  ld h,d
  ld l,e
  inc hl
  inc hl
  ld a,$00
  call nz,SetMem
_:
  inc de \ inc de
  ld c,e \ ld b,d
  ret
FixToken:
  ld a,(hl)
  cp 93h
  jr nz,SetMode
  call ParseNextFullArg
  ld a,c
  ld (TextPauseTime),a
  ret
SetMode:
  ld bc,(flags+34)
  ld b,0
  call ParseFullArg
  ld a,c
  ld (flags+34),a
  ret
OSVarToken:
  ld a,(hl)
  inc hl
  ld (parsePtr),hl
  ld hl,0
  ld (OP1+2),hl
  ld (OP1+1),a
  rst rFindSym
  jr c,return_BC_0
  ex de,hl
  call convFloat
  ld b,d \ ld c,e
  ret
return_BC_0:
  ld bc,0
  ret
TangentToken:
  call ParseFullArg
  xor a \ ld b,a
  or c
  ret z
  push bc
  call ParseNextFullArg
  ld a,c
  pop bc
  or a \ ret z
  push af
  push bc
  ld a,(hl)
  cp 2Bh
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  ld (TempWord1),bc
  pop bc
  pop af
ShiftGraphBuf:
  ld b,4
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphDownA
  pop af
  pop bc
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphLeftA
  pop af
  pop bc
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphRightA
  pop af
  pop bc
  rrca
  ld a,c
  ret nc
ShiftGraphUpA:
  ld e,a
  ld l,a
  ld h,0
  ld d,h
  add hl,hl
  add hl,de
  add hl,hl
  add hl,hl
  push hl
  ld a,h
  inc a
  cpl
  and 3
  ld b,a
  ld a,l
  dec a
  cpl
  ld c,a
  ld de,(TempWord1)
  add hl,de
  ldir
  pop bc
ZeroMemF:
  xor a
SetMemF:
  ld (de),a
  ld h,d \ ld l,e
  inc de
  ldir
  ret
ShiftGraphRightA:
  rrca
  push af
  call c,ShiftRight1
  pop af
  rrca
  push af
  call c,ShiftRight2
  pop af
  rrca
  push af
  call c,ShiftRight4
  pop af
  rrca
  push af
  call c,ShiftRight8
  pop af
  rrca
  push af
  call c,ShiftRight16
  pop af
  rrca
  push af
  call c,ShiftRight32
  pop af
  rrca
  ret nc
ShiftRight64:
  ld hl,(TempWord1)
  ld a,l
  sub 9
  jr nc,+_
  dec h
_:
  ld l,a
  ld a,4
  jr ShiftRight8OrMore
ShiftRight32:
  ld hl,(TempWord1)
  ld a,l
  sub 5
  jr nc,+_
  dec h
_:
  ld l,a
  ld a,8
  jr ShiftRight8OrMore
ShiftRight16:
  ld hl,(TempWord1)
  dec hl \ dec hl \ dec hl
  ld a,10
ShiftRight8OrMore:
  inc h
  inc h
  inc h
  ld b,0
  ld c,a
  ld (TempWord3),bc
  sub 13
  cpl
  ld (TempWord2+1),a
  ld b,64
  ld de,(TempWord1)
  inc d \ inc d \ inc d
  dec de
SR8OMLoop:
;TempWord2==number of bytes to clear
;TempWord3==number of bytes to shift
;b=64
  push bc
  ld bc,(TempWord3)
  lddr
  ld bc,(TempWord2)
  xor a
_:
  ld (de),a
  dec de
  dec hl
  djnz -_
  pop bc
  djnz SR8OMLoop
  ret
ShiftRight8:
  ld hl,(TempWord1)
  ld d,64
ShiftRight8_loop:
  xor a
  ld b,12
_:
  ld c,(hl)
  ld (hl),a
  inc hl
  ld a,c
  djnz -_
  dec d
  jr nz,ShiftRight8_loop
  ret
ShiftRight2:
  call ShiftRight1
ShiftRight1:
  ld hl,(TempWord1)
  ld c,64
ShiftRight1_loop:
  xor a
  ld b,12
_:
  rr (hl)
  inc hl
  djnz -_
  dec c
  jr nz,ShiftRight1_loop
  ret
ShiftRight4:
  ld hl,(TempWord1)
  ld c,64
ShiftRight4_loop:
  xor a
  ld b,12
_:
  rrd
  inc hl
  djnz -_
  dec c
  jr nz,ShiftRight4_loop
  ret
ShiftGraphLeftA:
  rrca
  push af
  call c,ShiftLeft1
  pop af
  rrca
  push af
  call c,ShiftLeft2
  pop af
  rrca
  push af
  call c,ShiftLeft4
  pop af
  rrca
  push af
  call c,ShiftLeft8
  pop af
  rrca
  push af
  call c,ShiftLeft16
  pop af
  rrca
  push af
  call c,ShiftLeft32
  pop af
  rrca
  ret nc
ShiftLeft64:
  ld hl,(TempWord1)
  ld a,8
  add a,l
  jr c,+_
  inc hl
_:
  ld l,a
  ld a,4
  jr ShiftLeft8OrMore
ShiftLeft32:
  ld hl,(TempWord1)
  inc hl \ inc hl
  inc hl \ inc hl
  ld a,8
  jr ShiftLeft8OrMore
ShiftLeft16:
  ld hl,(TempWord1)
  inc hl \ inc hl
  ld a,10
ShiftLeft8OrMore:
  ld b,0
  ld c,a
  ld (TempWord3),bc
  sub 13
  cpl
  ld (TempWord2+1),a
  ld b,64
  ld de,(TempWord1)
SL8OMLoop:
  push bc
  ld bc,(TempWord3)
  ldir
  ld bc,(TempWord2)
  xor a
_:
  ld (de),a
  inc de
  inc hl
  djnz -_
  pop bc
  djnz SL8OMLoop
  ret
ShiftLeft8:
  ld hl,(TempWord1)
  inc h \ inc h \ inc h
  dec hl
  ld d,64
ShiftLeft8_loop:
  xor a
  ld b,12
_:
  ld c,(hl)
  ld (hl),a
  dec hl
  ld a,c
  djnz -_
  dec d
  jr nz,ShiftLeft8_loop
  ret
ShiftLeft2:
  call ShiftLeft1
ShiftLeft1:
  ld hl,(TempWord1)
  inc h
  inc h
  inc h
  dec hl
  ld c,64
ShiftLeft1_loop:
  xor a
  ld b,12
_:
  rl (hl)
  dec hl
  djnz -_
  dec c
  jr nz,ShiftLeft1_loop
  ret
ShiftLeft4:
  ld hl,(TempWord1)
  inc h \ inc h \ inc h
  dec hl
  ld c,64
ShiftLeft4_loop:
  xor a
  ld b,12
_:
  rld
  dec hl
  djnz -_
  dec c
  jr nz,ShiftLeft4_loop
  ret
ShiftGraphDownA:
  ld e,a
  ld l,a
  ld h,0
  ld d,h
  add hl,hl
  add hl,de
  add hl,hl
  add hl,hl
  push hl
  ld a,h
  inc a
  cpl
  and 3
  ld b,a
  ld a,l
  dec a
  cpl
  ld c,a
  ld hl,(TempWord1)
  dec hl
  add hl,bc
  ld de,(TempWord1)
  inc d \ inc d \ inc d
  dec de
  lddr
  pop bc
ZeroMemE:
  xor a
SetMemE:
  ld (de),a
  ld h,d \ ld l,e
  dec de
  lddr
  ret
PiToken:
ConvHexStr:
  xor a
  ex de,hl
  ld h,a
  ld l,a
_:
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  or l
  ld l,a
  call IsHexTok
  jr nc,-_
_:
  dec de
  ld (parsePtr),de
  ld b,h \ ld c,l
  ex de,hl
  ret
#ifdef include_ncr
#include "cmd/ncr.z80"
#endif
ForToken:
  push bc
  ld a,(hl)
  inc hl
  call VarP
  jr c,+_
  ld hl,ForBackUp
  push hl
  ld (hl),1
  inc l
  ld (hl),0
  call ParseFullArg
  jr StartForLoop-4
_:
  ld (parsePtr),de
  push hl
  call ParseNextFullArg
  pop hl
  push  hl
  ld (hl),c \ inc hl
  ld (hl),b
  call ParseNextFullArg
  ld e,c
  ld d,b
  pop hl
  pop bc
StartForLoop:
  push de              ;UpperBound
  push hl              ;varPointer
  ld hl,(parsePtr)
  push hl
  call ParserNext
  pop hl
  ld (TempWord2),hl
  ld (TempWord1),bc
  pop hl                ;points to var data
  pop de                ;upper bound
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc bc
  ld (hl),b
  dec hl
  ld (hl),c
  ex de,hl
  or a
  sbc hl,bc
  add hl,bc
  ld bc,(TempWord1)
  ret c
  push hl
  ld hl,(TempWord2)
  ld (parsePtr),hl
  pop hl
  ex de,hl
  jr StartForLoop
FullToken:
  ld a,(hl)
  ld c,1
  call EndOArg
  call nz,ParseFullArg
SetSpeed:
  in a,(20h)
  ld b,a
  bit 1,c
  jr z,+_
  cpl
  and 1
  ld c,a
_:
  in a,(2)
  rlca
  and c
  out (20h),a
  ld c,b
  ld b,0
  ret
ClrDrawToken:
  ld a,(hl)
  call EndOArg
  jr z,g_ClrDraw
  call ParseFullArg
  ld h,b \ ld l,c
  ld d,b \ ld e,c
  jp ZeroMem768
g_ClrDraw:
  ld de,0
  ld (textRow),de
  push bc
  ld hl,(BufPtr)
  pop de
ZeroMem768:
  ld bc,768
ZeroMem:
  ld a,b \ or c \ ld a,0
  push de
  call nz,SetMem
  pop bc
  ret
ClrHomeToken:
g_ClrHome:
  ld hl,0
  ld (CurRow),hl
  push bc
  ld b,128
  ld hl,textShadow
  ld a,' '
  call SetSmallMem
  pop bc
  ret
minToken:
maxToken:
  push af
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  pop af
g_max:
  or a
  sbc hl,bc
  add hl,bc
  bit 0,a
  jr nz,+_
  ccf
_:
  ret c
  ld b,h
  ld c,l
  ret
factorialToken:
  ld a,(hl)
  call IsConditional \ jr z,+_
  ld de,0 \ push de
  jp factorialStepIn
_:
  set invlogic,(iy+gflags)
  ret
FillToken:
  call ParseFullArg
  ld hl,(BufPtr)
  ld a,c
  ld bc,300h
  ld e,-1
FillBufOR:
  or a \ jr nz,FillBufInv
_:
  ld a,e \ or (hl) \ ld (hl),a
  cpi
  jp pe,-_
  ret
FillBufInv:
  dec a \ jr nz,Checker1
_:
  ld a,e \ xor (hl) \ ld (hl),a
  cpi
  jp pe,-_
  ret
Checker1:
  dec a \ jr nz,Checker2
  ld a,$AA
Checker:
  ld c,64
Checker1_loop:
  ld b,12
_:
  ld (hl),a
  inc hl
  djnz -_
  cpl \ dec c
  jr nz,Checker1_loop
  ret
Checker2:
  dec a \ jr nz,LoadBytePatternOR
  ld a,55h \ jr Checker
LoadBytePatternOR:
  cp 22 \ jr nc,NotArg
  push af \ push bc \ push hl
  call ParseNextFullArg
  ld d,b \ ld e,c \ pop hl \ pop bc \ pop af
NotArg:
  dec a \ jr z,FillBufOR+3
LoadBytePatternXOR:
  dec a \ jr z,FillBufInv+3
LoadBytePatternAND:
  dec a \ jr nz,LoadBytePatternErase
FillBufAND:
  ld a,e \ and (hl) \ ld (hl),a
  cpi
  jp pe,FillBufAND
  ret
LoadBytePatternErase:
  dec a \ jr nz,BufCopy
FillBufErase:
  ld a,e \ cpl \ and (hl) \ ld (hl),a
  cpi
  jp pe,FillBufErase
  ret
BufCopy:
  dec a \ jr nz,BufOR
  jp mov768
BufOR:
  dec a \ jr nz,BufAND
  ld a,(de) \ inc de
  or (hl) \ ld (hl),a
  cpi \ jp pe,BufOR+3
  ret
BufAND:
  dec a \ jr nz,BufXOR
  ld a,(de) \ inc de
  and (hl) \ ld (hl),a
  cpi \ jp pe,BufAND+3
  ret
BufXOR:
  dec a \ jr nz,BufErase
  ld a,(de) \ inc de
  xor (hl) \ ld (hl),a
  cpi \ jp pe,BufXOR+3
  ret
BufErase:
  dec a \ jr nz,BufSwap
  ld a,(de) \ inc de
  cpl \ and (hl) \ ld (hl),a
  cpi \ jp pe,BufErase+3
  ret
BufSwap:
  dec a \ jr nz,CopyDown
  ld a,(de)
  push af \ ld a,(hl) \ ld (de),a
  pop af \ ld (hl),a
  inc de
  cpi \ jp pe,BufSwap+3
  ret
CopyDown:
;If Copy Down
  cp 5 \ jr nc,CopyDownOR
  add hl,bc \ dec hl
  push hl
  ld h,d \ ld l,e
  add hl,hl \ add hl,de
  add hl,hl \ add hl,hl
  pop de \ push de \ push hl \ ex de,hl
  sbc hl,de \ ex de,hl
  ld h,b \ ld l,c \ pop bc \ sbc hl,bc
  ld b,h \ ld c,l
  pop hl
CopyDownOR:
  dec a \ jr nz,CopyDownAND
_:
  ld a,(de)
  or (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,-_
  ret
CopyDownAND:
  dec a \ jr nz,CopyDownXOR
_:
  ld a,(de)
  and (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,-_
  ret
CopyDownXOR:
  dec a \ jr nz,CopyDownErase
_:
  ld a,(de)
  xor (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,-_
  ret
CopyDownErase:
  dec a \ jr nz,CopyUp
_:
  ld a,(de)
  cpl
  and (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,-_
  ret
CopyUp:
;If Copy Up
  cp 5 \ jr nc,CopyUpOr
;de is number of pixels down to copy to
;bc is 768
;hl points to the buffer
  push hl
  ld h,d \ ld l,e
  add hl,de \ add hl,de
  add hl,hl \ add hl,hl
  ld b,h \ ld c,l
  pop de \ add hl,de
;DE points to main buffer
;HL points to offset
  push hl
  ld hl,768 \ sbc hl,bc
  ld b,h \ ld c,l
  pop hl
  ex de,hl
CopyUpOR:
  dec a \ jr nz,CopyUpAND
_:
  ld a,(de)
  or (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,-_
  ret
CopyUpAND:
  dec a \ jr nz,CopyUpXOR
_:
  ld a,(de)
  and (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,-_
  ret
CopyUpXOR:
  dec a \ jr nz,CopyUpErase
_:
  ld a,(de)
  xor (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,-_
  ret
CopyUpErase:
#ifdef include_fire
  dec a \ jr nz,+_
#else
  dec a \ ret nz
#endif
_:
  ld a,(de)
  cpl
  and (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,-_
  ret
_:
#ifdef include_fire
#include "cmd/fire.z80"
#endif
HorizontalToken:
  call ParseFullArg

  ld a,b \ or a \ ret nz
  ld a,c
  cp 64
  ret nc
  push bc
  ld c,1
  ld a,(hl)
  cp 2Bh
  call z,ParseNextFullArg
  ld d,c
  cp 2Bh
  push de
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  pop de
  pop hl
  push bc
  ld b,h
  ld c,l
  add hl,hl \ add hl,bc
  add hl,hl \ add hl,hl
  ld a,d
  pop bc
  add hl,bc
  ld b,12
  or a
  jr z,SetSmallMem
  dec a
  jr nz,InvertMem
  dec a
SetSmallMem:
  ld (hl),a
  inc hl
  djnz SetSmallMem
  ret
InvertMem:
  ld a,(hl)
  cpl
  ld (hl),a
  inc hl
  djnz InvertMem
  ret
VerticalToken:
  call ParseFullArg
  ld a,b \ or a \ ret nz
  ld a,c \ cp 96 \ ret nc
  ld a,c
  and 7
  ld b,a
  ld a,80h
  jr nz,skip_vert_mask
_:
  rrca
  djnz -_
skip_vert_mask:
  srl c \ srl c \ srl c
  push af
  push bc
  ld a,(hl) \ cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  ld b,c
  push bc
  ld bc,(BufPtr)
  cp 2Bh
  call z,ParseNextFullArg
  pop af
  pop hl
  add hl,bc
  pop bc
  ld c,b
;=======================================
;     C is the mask
;     A is the method:
;        0=Off
;        1=On
;        2=Invert
;     HL is where to start
;=======================================
  ld b,64
  ld de,12
DrawVertOn:
  dec a \ jr nz,DrawVertInv
_:
  ld a,c
  or (hl)
  ld (hl),a
  add hl,de
  djnz -_
  ret
DrawVertInv:
  dec a \ jr nz,DrawVertOff
_:
  ld a,c
  xor (hl)
  ld (hl),a
  add hl,de
  djnz -_
  ret
DrawVertOff:
  ld a,c
  cpl
  ld c,a
_:
  ld a,c
  and (hl)
  ld (hl),a
  add hl,de
  djnz -_
  ret
ShadeToken:
  call ParseFullArg
  ld a,c
  add a,$D9
  jr nc,+_
  xor a
_:
  dec a
  out (16),a
  ret
StorePicToken:
  call ParseFullArg
  ld b,c
  ld c,60h
  push bc
  cp 2Bh
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  pop hl
  push bc
  ld (OP1+1),hl
  xor a
  ld (OP1+3),a
  rst rFindSym
  jr c,+_
  bcall(_DelVarArc)
_:
  ld hl,768
  ld a,7
  bcall(_CreateVar)   ;_CreatePict only stores 756 bytes.
  inc de
  inc de
  pop hl
mov768:
;14656cc vs 16123cc
  ld bc,768
_:
  call mov12
  jp pe,-_
  ret
RecallPicToken:
  call ParseFullArg
  push bc
  cp 2Bh
  ld c,0
  call z,ParseNextFullArg
  ld b,c
  push bc
  ld bc,(BufPtr)
  cp 2Bh
  call z,ParseNextFullArg
  pop af
  ex af,af'
  ld d,b
  ld e,c
  pop bc
  push de
;de buffer to store to
;bc is pic num
;A' is the method to copy with
  ld b,c
  ld c,60h
  ld (OP1+1),bc \ rst rFindSym
  pop hl
  ret c
  push hl
  ld a,b
  ld b,0
  push af
  call GetVarInfoVarFound
  dec bc
  ld a,b
  inc bc
  sub 3
  jr c,+_
  ld bc,768
_:
  pop af
  ld de,saveSScreen
  push bc
  push de
  call ReadArc
  pop hl
  pop bc
  pop de
  ex af,af'
;'
  or a
  jp z,BufCopy+3
  ex de,hl
  dec a
  jp z,BufAND+3
  dec a
  jp z,BufXOR+3
  dec a
  jp z,BufOR+3
  dec a
  ret z
  dec a
  jp z,BufErase+3
  ret
BBTokens:
  ld a,(hl)
  inc hl
  cp $64    ;the G-T token
  jr nz,lowercasetokens
  ld a,(hl)
  ld bc,9340h
  cp $AE
  jr nz,+_
  inc hl
  ld bc,9872h
_:
  ld (parsePtr),hl
  ret
lowercasetokens:
  ld (parsePtr),hl
  cp $B0
  jr c,length
  cp $CB
  jr nc,length
  cp $BB
  jr c,+_
  dec a
_:
  sub $AC
  add a,a
  inc a
  ex de,hl
  ld l,a
  ld h,91h
  ld c,(hl)
  inc l
  ld b,(hl)
  ex de,hl
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  ld (parsePtr),de
  ld d,b
  ld e,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  set FactorialFlag,(iy+InternalFlag)
  ret
length:
  cp 2Bh \ jr nz,inString
  ld a,(hl)
  cp $AE  ;'
  jr nz,FindVarInfo
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  ld bc,3Fh
  cp 2Bh \ call z,ParseNextFullArg
  ld a,c
  pop de
  pop bc
  pop hl
  call SearchLine
  ld (ThetaPrimeVar),hl
  ld b,d \ ld c,e
  ret
;HL is start address
;BC is the line number
;E is the NewLine byte
FindvarInfo:
  call GetVarInfo2
  ld (ThetaPrimeVar),hl
  ret nc
  ld bc,-1
  ret
inString:
  cp 15 \ jr nz,conj
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  cp 2Bh        ;If there is another argument, then it is to put a limit on how mnay bytes to compare
  ld h,b \ ld l,c
  push hl
  jr z,+_
  call nz,GetGrammerStr
  cp a
_:
  call z,ParseNextFullArg
  ld (ThetaPrimeVar),bc
  pop de
  pop hl
  push bc
  call SearchString
  pop bc
  jr c,+_
  ld h,b \ ld l,c
_:
  or a \ sbc hl,bc
  ld b,h \ ld c,l
  ret
conj:
;n = f(x) = 440*(12th root (2^(x-48))
;A=1, B=3, C=4, D=6, E=8, F=9, and G=11
;Sharp is add 1
;flat is minus 1
  cp 37 \ jr nz,subToken
  ei
  ld a,(hl)
  cp $AE
  jr nz,GrammerSound
  call ParseNextFullArg
  push bc
  inc hl \ ld a,(hl)
  cp $AE \ push af
  call ParseNextFullArg
  pop af
  jr nz,SoundData
  ld h,b \ ld l,c \ pop bc
p_FreqOut:
  xor a
__FreqOutLoop1:
  push bc
  xor 3
  ld e,a
_:
  ld a,h
  or l
  jr z,+_
  cpd
  jp pe,-_
  ld a,e
  scf
_:
  pop bc
  out (0),a
  ret nc
  jr __FreqOutLoop1
__FreqOutEnd:
SoundData:
  push bc
  call ParseNextFullArg
  pop hl \ pop de
  ld a,b \ or c \ ret z
;HL points to the data:
;DE is the time
;BC is the number of elements
SoundLoop:
  push de \ push bc
  ld c,(hl) \ inc hl
  ld b,(hl) \ push hl
  ex de,hl
  call p_FreqOut
  pop hl \ pop bc \ pop de
  cpi
  jp pe,SoundLoop
  ret
GrammerSound:
  call ParseFullArg
  push bc
  call ParseNextFullArg
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  pop bc
  add hl,bc
  add hl,hl
  push hl
  call ParseNextFullArg
  ld d,b
  ld e,c
  pop hl
  ld bc,FrequencyLUT
  add hl,bc
  ld c,(hl)
  inc hl
  ld b,(hl)
NoteLoop:
  ld a,d
  or e
  ret z
  push de
  ld hl,4096
  call p_FreqOut
  pop de
  dec de
  jp NoteLoop
subToken:
  cp 12 \ jr nz,ANOVAsubset
  call ParseFullArg
  push bc
  call ParseNextFullArg
  push bc
  ld hl,(parsePtr)
  inc hl
  ld (parsePtr),hl
  call GetVarInfo
  jp c,Pop2Exit
  or a \ jp nz,Pop2Exit
  ld hl,(parsePtr)
  ld (parsePtr),hl
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld (TempWord1),hl
  ld h,b \ ld l,c
  pop bc
  sbc hl,bc
  pop de
  ret c
  sbc hl,de
  jr nc,DelGoodSize
  ex de,hl
  add hl,de
  ld h,a \ cp l \ ret z
  ex de,hl
  ld hl,0
DelGoodSize:
  add hl,bc
  push de
  ld de,(TempWord1)
  ex de,hl
  dec hl \ ld (hl),d
  dec hl \ ld (hl),e
  inc hl \ inc hl
  add hl,bc
  pop de
  push hl
  ld a,d \ or e
  jr z,+_
  bcall(_DelMem)
_:
  ld hl,(parsePtr)
;  ld (parsePtr),hl   ;seems redundant, I probably messed up when I was cleaning the code.
  pop bc
  ret
ANOVAsubset:
DelvarToken:
  cp 54h \ jr nz,UnArchiveToken
  call GetVarInfo \ ret c
  bcall(_DelVarArc)
  ret
UnArchiveToken:
  cp 69h \ jr nz,ArchiveToken
  call GetVarInfo \ ret c
  or a \ ret z
  bcall(_Arc_Unarc)
  bcall(_ChkFindSym)
  ex de,hl
  ld e,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ex de,hl \ ld c,e \ ld b,d
  ld (ThetaPrimeVar),hl
  ret
ArchiveToken:
  cp 68h \ jr nz,AsmToken
  call GetVarInfo \ ret c
  or a
  ret nz
  bcall(_Arc_Unarc)
  ret
AsmToken:
  cp 6Ah \ jr nz,expr
; jr $
  push bc
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  ld hl,9D95h ;start VarRAM
  ld (TempWord1),hl
  pop hl \ ld (TempWord2),hl
  bcall(_ChkFindSym)
  ld a,b
  ld (TempWord3),a
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld a,(hl) \ inc hl \ cp $BB
  ret nz
NotASMHeader:
  ld a,(hl) \ inc hl \ cp $6D
  jr nz,CheckUnsquishedHex
StartASMProg:
  dec bc \ dec bc
;BC is size of the data
;HL points to the bytes to copy
;(TempWord3) is the flash page
  push hl \ push bc
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
;HL # bytes
;DE addr
  ld de,9D95h ;start VarRAM
  push de
  bcall(_InsertMem)
  pop de \ pop bc \ pop hl
  ld a,(TempWord3) \ or a
  jr nz,+_
  add hl,bc
_:
  push bc
  call ReadArc
  pop de
  jr +_
CheckUnsquishedHex:
  cp 6Ch \ jr nz,NotASMHeader
  jr NotASMHeader
_:
  ld hl,(parsePtr)
  add hl,de
  ld (parsePtr),hl
;===============================================================
CallProg:
  ld bc,(TempWord2)
  push de
  ld de,AfterRet \ push de
  ld de,(TempWord1) \ push de
  ret
AfterRET:
  ld hl,(parsePtr)
  pop de
  or a
  sbc hl,de
  ld (parsePtr),hl
  ld hl,9D95h ;start VarRAM
;Delmem: HL address
;        DE # of bytes
  bcall(_DelMem)
  ret
expr:
  cp 2Ah \ jr nz,AsmPrgm
  call ParseFullArg
g_expr:
  ld hl,(parsePtr) \ push hl
  ld (parsePtr),bc
  call ParseCondition
  pop hl
  ld (parsePtr),hl
  ret
AsmPrgm:
  cp 6Ch \ jr nz,OMNom
  push bc
  ld b,h \ ld c,l
  call ConvHexTo86ECh
  ex de,hl
  ld (parsePtr),hl
  pop bc
  jp 86ECh
OMNom:
;Note from Future Zeda: "I love you, Past Zeda."
;        cp 5 \ jr nz,BBrandInt
;          dec hl \ dec hl \ dec hl
;          ld a,(hl) \ cp 4Dh \ ret nz
;          dec hl
;          ld a,(hl) \ cp 4Fh \ ret nz
;          call ParseFullArg
;          ld a,c \ and 3
;          add a,12
;          out (16),a
;          ret
BBrandInt:
  cp 10 \ jr nz,BBLCM
  call ParseFullArg
  push bc
  push bc
  call ParseNextFullArg
  push bc
  call prng16
  ld b,h
  ld c,l
  pop hl
  pop de
  or a \ sbc hl,de
  call HL_Times_BC
  pop hl \ add hl,de
  ld b,h \ ld c,l
  ret
BBLCM:
  cp 8
  jr nz,BBGCD
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop de
LCM_BC_DE:
  push de
  call DE_Times_BC
  ex (sp),hl
  call GCDHL_BC
  pop hl
  call HL_Div_BC
  ld b,h
  ld c,l
  ret
BBGCD:
  cp 9
  ret nz
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
GCDHL_BC:
  ld d,b
  ld e,c
#include "math/gcdHL_DE.z80"
CircleToken:
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld d,c
  push de
  call ParseNextFullArg
  push bc
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  push bc
  ld c,00
  cp 2Bh
  call z,ParseNextFullArg
  ld a,c
  pop bc
  ld b,a
  ld (TempWord1),bc
  ld a,(hl)
  cp 2Bh
  call ParseNextFullArg_Buffer
  pop bc
  pop de
  jp Circle
PauseToken:
  ld a,(hl)
  call EndOArg
  push bc
  jr nz,NotBASICPause
  ld h,9
_:
  ld bc,1
  call g_Pause
  ld a,h
  call CheckKey
  jr z,-_
_:
  ld bc,1
  call g_Pause
  ld a,h
  call CheckKey
  jr nz,-_

  pop bc
  ret
NotBASICPause:
  ld a,(hl) \ cp $CE \ jr nz,Pause
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  inc hl
  jr z,Pauseif
  jr PauseNotIf
Pause:
  call ParseFullArg
  pop de
g_Pause:
  push de
  ei
_:
  halt
  dec bc
  ld a,b
  or c
  jr nz,-_
  pop bc
  ret
PauseIf:
  call PauseIfLoop
  jr nz,PauseIf
  pop bc \ ret
PauseNotIf:
  call PauseIfLoop
  jr z,PauseNotIf
  pop bc \ ret
PauseIfLoop:
  ld (parsePtr),hl \ push hl
  call ParseCondition
  xor a \ ld h,a \ ld l,a \ sbc hl,bc
  pop hl
  ret
PxlTokens:
  sub $A0
PxlTestToken:
  push af
  ld a,(hl)
  cp $AE
  ;jr z,PxlTestBox
  jp z,ErrBadToken
  call ParseFullArg
  push bc
  call ParseNextFullArg
  cp 2Bh
  ld a,c
  push af
  call ParseNextFullArg_Buffer
  pop af
  pop bc
  ld b,a
  pop de
PlotPixel:
  call GetPixelLoc
  ld bc,0
  jr c,+_
  bit pxlBoundsRes,(iy+UserFlags)
  ret z
  inc c
  ret
_:
  ld e,a
  and (hl)
  jr z,+_
  inc c
_:
  dec d
  jr nz,+_
  ld a,e \ or (hl) \ ld (hl),a \ ret
_:
  dec d
  jr z,+_
  dec d
  ret nz
  ld a,e
_:
  xor (hl) \ ld (hl),a \ ret
prgmToken:
  ld (TempWord1),bc
  ld a,(hl) \ inc hl
  cp $10
  jr nz,+_
  ld (parsePtr),hl
  ld a,(hl)
  inc hl
_:
  push af
  call VarP
  ex (sp),hl
  push af
  push hl
  call ParseFullArg
  pop af
  jr nz,g_Call
  inc hl
  ld (qmarkVar),hl
  .db $C2   ;start of jp nz,*, basically skips the 'or 1'
g_Call:
  or 1
  push af
  ld de,(progStart)
  ld hl,(parsePtr)
  or a
  sbc hl,de
  push hl
  ex de,hl
  sbc hl,bc
  push hl
  ld (parsePtr),bc
  ld bc,(TempWord1)
  call ParserNext
  pop hl
  pop de
  push hl
  ld hl,(progStart)
  add hl,de
  ld (parsePtr),hl
  pop de
  ld hl,(progStart)
  sbc hl,de
  ex de,hl
  pop af
  jr nz,+_
  pop af
  pop hl
  ld hl,(qmarkVar)
  ld (parsePtr),hl
  ret
_:
  pop af \ pop hl
  ret nc
  ld (hl),e \ inc hl
  ld (hl),d
  ret
DispToken:
  ld a,(hl)
  cp 11
  jr z,GrayBufOnly
  cp $AE
  jr z,BlackBufOnly
  call ParseFullArg
  ld (BufPtr),bc
  ld (GrayBufPtr),bc
  ret
GrayBufOnly:
  call ParseNextFullArg
  ld (GrayBufPtr),bc
  ret
BlackBufOnly:
  call ParseNextFullArg
  ld (BufPtr),bc
  ret
TextToken:
  ld a,(hl)
  cp 4 \ jr z,+_
  cp 3Eh \ jr z,+_
  cp 3Fh \ jr nz,NoRC
_:
  ld bc,(textRow)
  ld l,b \ ld b,0
  ld h,b
  ld (ThetaPrimeVar),hl
  ret
NoRC:
  res SlowTextFlag,(iy+InternalFlag)
  cp 10
  jr nz,+_
SlowText:
  set SlowTextFlag,(iy+InternalFlag)
  inc hl
  ld (parsePtr),hl
  ld a,(hl)
_:
  cp $AE
  jp nz,FindingTextStr
  inc hl
  ld (parsePtr),hl
  call LoadTextCoordinates
  call ParseNextFullArg
  push bc
  push de
  ld a,(hl)
  cp 2Bh
  ld c,10
  call z,ParseNextFullArg+3

  ld hl,OP2
  ld (hl),0
  ld (TempWord1),hl
  pop de
  pop hl
  bit SignedText,(iy+UserFlags)
  jr z,+_
  bit 7,h
  jr z,+_
  ld a,l \ cpl \ ld l,a
  ld a,h \ cpl \ ld h,a
  inc hl
  push de \ push hl \ push bc
  ld a,1Ah \ call PutSC
  pop bc \ pop hl \ pop de
_:
  dec c
  ret z
  inc c
  ret z
DispNumBase32:
;Inputs:
;     C is the base (use 2 to 36)
;     DEHL is the number to display
;
  ld b,32
  xor a
DispNumBase32_loop:
  add hl,hl
  rl e \ rl d
  rla
  cp c
  jr c,+_
  inc l
  sub c
_:
  djnz DispNumBase32_loop
  push bc
  push de
  push hl
  add a,30h
  cp 3Ah
  jr c,+_
  add a,7
_:
  ld hl,(TempWord1)
  dec l
  ld (TempWord1),hl
  ld (hl),a
  pop hl
  pop de
  pop bc
  ld a,h
  or l \ or d \ or e
  jr nz,DispNumBase32
  ld hl,(TempWord1)
  jp GPutS
;===============================================================
PutSM:
;===============================================================
;Inputs:
;     hl points to the string to display
;     bc is the size of the string
;===============================================================
  ld a,b \ or c \ ret z
_:
  push bc
  push hl
  ld a,(hl)
  call PutSC
  pop hl
  pop bc
  cpi
  jp pe,-_
  ret
FindingTextStr:
  call LoadTextCoordinates
  ret nz
  inc hl
  ld a,(hl)
  cp 3Ah      ;. displays a float
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld hl,single2str
  ld (next_page_call_address),hl
  ld h,b
  ld l,c
  ld bc,OP1
  call next_page_call
  ld h,b
  ld l,c
  jp GPutS
_:
  cp $AE
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld a,c
  jp PutSC
_:
  cp 11
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld h,b \ ld l,c
  jp GPutS
_:
  call ParseNextFullArg
  push bc
  set Xis0,(iy+ParticleFlag)
  cp 2Bh
  jr nz,+_
  call ParseNextFullArg
  xor a
_:
  pop hl
  jr z,TokenTextLoop
PutTokenText:
;    HL points to the string
  res Xis0,(iy+ParticleFlag)
  ld bc,-1
TokenTextLoop:
  ld a,(hl)
  bit Xis0,(iy+ParticleFlag)
  jr nz,+_
  or a
  ret z
  cp 4
  ret z
  cp 3Fh
  ret z
  cp 2Ah
  ret z
_:
  push  hl
  push bc
  bcall(_Get_Tok_Strng)
  pop hl
  or a
  sbc hl,bc
  jr nc,+_
  add hl,bc
  ld b,h
  ld c,l
  ld l,0
_:
  pop de
  push hl
  ld a,(de)
  call Is_2_Byte
  jr nz,+_
  inc de
_:
  push de
  ld hl,OP3
  call PutSM
  pop hl
  pop bc
  inc bc
  cpi
  jp pe,TokenTextLoop
  ret
;===============================================================
LoadTextCoordinates:
;===============================================================
  ld a,(hl)
  cp 11
  jr nz,+_
  ld (parsePtr),hl
  ret
_:
  ld bc,(textRow)
  call ParseFullArg
  ld a,c
  ld (textRow),a
  ld bc,(textCol)
  call ParseNextFullArg
  ld a,c
  ld (textCol),a
  ld a,(hl)
  cp 2Bh
  ret
;===============================================================
PtOff:
  call ParseFullArg
  ld a,c
  and 7
  push af
  bit 3,c
  push af
  call ParseNextFullArg
  pop af
  jr z,+_
  call ConvHexTo86ECh
  ld bc,86ECh
_:
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld d,c
  push de
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  cp 2Bh
  ld c,8
  call z,ParseNextFullArg
  ld l,1
  ld h,c
  push hl
  ld hl,(parsePtr)
  ld a,(hl)
  cp $2b
  call ParseNextFullArg_Buffer
  pop hl
  pop bc
  pop de
  pop af
#include "gfx/sprite.z80"


LineToken:
  ld a,(hl)
  cp $AE
  jp z,gfx_line


;     A is the type of rectangle to draw
;        0 =White
;        1 =Black
;        2 =XOR
;        3 =Black border
;        4 =White border
;        5 =XOR border
;        6 =Black border, white inside
;        7 =Black border, XOR inside
;        8 =White border, black inside
;        9 =White border, XOR inside
;        10=Shift Up
;        11=Shift Down
;     B is the height
;     C is the Y pixel coordinate
;     D is the width in pixels
;     E is is the X pixel coordinate

;So we get E,C,B,D,A
  call ParseFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop hl
  ld h,c
  push hl
  call ParseNextFullArg
  push bc
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  push bc
  cp 2Bh
  call ParseNextFullArg_Buffer
  pop bc    ;method in C
  ld a,c
  pop hl    ;L is what needs to be the D value
  pop bc
  pop de
  ld d,l
  jp DrawRectToGraph
gfx_line:
;x1,y1,x2,y2[,method[,buffer
;

  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld b,e
  push bc

  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld b,e
  push bc

  ld c,1
  cp $2B
  call z,ParseNextFullArg
  push bc

  ld bc,(BufPtr)
  cp $2B
  call z,ParseNextFullArg
  ld h,b
  ld l,c
  pop bc
  ld a,c
  pop de
  pop bc
#include "gfx/line.z80"
LeftParantheses:
;Read a byte
  call ParseFullArg
  ld h,b
  ld l,c
  ld c,(hl)
  ld b,0
  ret
LeftBracket:
;Read a word (little endian)
  call ParseFullArg
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  ret
iPart:
;Write a word (little endian)
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  ld b,d
  ld c,e
  ret

int:
;Write byte
  ld a,(hl)
  cp $3A
  jr z,intf
  cp $AE      ;checks for '
  push af
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  pop af
  jr nz,+_ ;Write a byte
  ld a,(bc)
  ld e,(hl)
  ld (hl),a
  ld a,e
  ld (bc),a
  ret
_:
  ld e,(hl)
  ld (hl),c
  ld c,e
  ld b,$00
  ret
intf:
  call ParseNextFullArg
  ld hl,singleTo_int16
  ld (next_page_call_address),hl
  ld h,b
  ld l,c
  call next_page_call
  ld b,h
  ld c,l
  ret
GetToken:
  ld a,(hl)
  cp $AE
  jp z,GetByte
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
VarTokenStepIn:
  jp c,return_BC_0
  inc de
  inc de
  ld c,a
  ld (ThetaPrimeVar),bc
  ld b,d
  ld c,e
  ret
RepeatToken:
  push hl
  ex de,hl
  pop hl
  call EndOfLine
  ld (parsePtr),hl
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  jr nz,NotRepeatLoop
RepeatLoop:
  call RepeatLooper
  jr z,RepeatLoop
ExitRepeat:
  ld (parsePtr),hl
  ret
NotRepeatLoop:
  call RepeatLooper
  jr nz,NotRepeatLoop
  jr ExitRepeat
RepeatLooper:
  push de
  call ParserNext
  ld hl,(parsePtr)
  pop de
  push de
  push hl
  ld (parsePtr),de
  push bc
  call ParseCondition
  ld a,b \ or c
Pop3Exit:
  pop bc
Pop2Exit:
  pop hl
Pop1Exit:
  pop de
  ret
WhileToken:
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  jr nz,NotWhileLoop
WhileLoop:
  push hl
  ld (parsePtr),hl
  call ParseCondition
  ld a,b
  or c
  jr z,EndWhileLoop
  call ParserNext
  pop hl
  jr WhileLoop
NotWhileLoop:
  push hl
  ld (parsePtr),hl
  call ParseCondition
  ld a,b
  or c
  jr nz,EndWhileLoop
  call ParserNext
  pop hl
  jr NotWhileLoop
EndWhileLoop:
  pop de
  call FindEndToken
  ld (parsePtr),hl
  ret
EndToken:
  pop de
  ret
ErrorJump:
  bit errorChecking,(iy+InternalFlag)
  ret nz
  push de
  push hl
  push bc
  ld hl,(parsePtr)
  ld (ErrorLoc),hl
  set errorChecking,(iy+InternalFlag)
  ld hl,(parseError)
  ld a,h
  or l
  ld a,(cxErrorEP)
  call z,GramHandl
  jr z,L5c05
  ld c,a
  ld b,0
  ld de,(parsePtr)
  ld (qmarkVar),de
  ld (parsePtr),hl
  ld hl,(ThetaPrimeVar)
  push hl
  ld hl,(Ans)
  ld (Ans),bc
  push hl
  call ParserNext
  ld a,(hl)
  ld hl,(qmarkVar)
  ld (parsePtr),hl
  cp $11
  jr nz,+_
  pop hl
  pop hl
  pop hl
  jr L5c06
_:
  pop hl
  ld (Ans),hl
  pop hl
  ld (ThetaPrimeVar),hl
L5c05:
  pop bc
L5c06:
  pop hl
  pop de
  res errorChecking,(iy+InternalFlag)
  ret
PtOn:
  call ParseFullArg
  ld a,c \ and 7
  res SlowTextFlag,(iy+InternalFlag)
  bit 3,c
  jr z,+_
  set SlowTextFlag,(iy+InternalFlag)
_:
  push af
  cp 7 \ jr nz,+_
  ld hl,flags+33
  ld a,16
  xor (hl)
  ld (hl),a
_:
  call ParseNextFullArg
  bit SlowTextFlag,(iy+InternalFlag)
  jr z,+_
  call ConvHexTo86ECh
  ld bc,saveSScreen
_:
  push bc
  call ParseNextFullArg
  ld (TempWord2),bc
  ld b,0
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  push hl
  call ParseNextFullArg
  pop hl
  add hl,bc
  push hl
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  ld b,c
  push bc
  cp 2Bh
  ld c,$08
  call z,ParseNextFullArg
  pop af
  ld b,a
  ld a,(TempWord2)
  add a,c \ dec a \ sub 64
  jr c,HeightIsFinePtOn
  ld d,a \ ld a,c \ sub d \ ld c,a \ dec c
HeightIsFinePtOn:
  push bc
  ld bc,(BufPtr)
  ld hl,(parsePtr)
  ld a,(hl)
  cp 2Bh
  call z,ParseNextFullArg
  ld d,b \ ld e,c
  pop bc
  pop hl
  add hl,de
  pop de
  ld a,(TempWord2) \ inc a \ sub 64 \ jp nc,pop1exit
  pop af
DrawSpriteXxY:
  push hl
  ld hl,bigtile
  ld (next_page_call_address),hl
  pop hl
  jp next_page_call
QuoteToken:
  push hl
  call GetGrammerStr
  ld (parsePtr),hl
  ld (ThetaPrimeVar),bc
  pop bc
  ret
GetKeyToken:
  ld a,(hl)
  cp 16
  jr nz,GetKey
  call ParseNextFullArg+3
  ld a,c
CheckKey:
;46 bytes:
;Input:
;     A is the key to test for
;Output:
;     BC is 1 if the key is pressed, 0 if it is not
;     z if the key is pressed, nz if not
  cp 41 ;on-key
  jr z,check_for_ON_key
_:
  dec a \ and 63
  ld b,a
  and 7
  srl b \ srl b \ srl b
  inc b \ inc a
  ld c,a
  ld a,7Fh
_:
  rlca
  djnz -_
  out (1),a
  ld b,c
  ld a,7Fh
_:
  rlca
  djnz -_
  ld c,a
  in a,(1)
  cp c
CheckKey_End:
  ld c,b
  ret nz
  inc c
  ret
check_for_ON_key:
  call CheckStatus
  ld bc,0
  ret nz
  inc c
  ret
GetKeyDebounce:
  ei
  halt
  call GetKey
  ld hl,k_save
  cp (hl)
  jr nz,newkeypress
;if the keys match, decrement k_count
  inc hl
  dec (hl)
  jr z,+_
  xor a
  ret
_:
  inc hl
  ld a,(hl)
  sub K_DELAY_ACCEL+1
  jr nc,+_
  xor a
_:
  inc a
  ld (hl),a
  dec hl
  ld (hl),a
  dec hl
  ld a,(hl)
  ret
newkeypress:
  ld (hl),a
  inc hl
  ld (hl),K_DELAY_DEFAULT
  inc hl
  ld (hl),K_DELAY_DEFAULT
  ret
;===============================================================
GetKey:
;===============================================================
;Outputs:
;     a is a value from 0 to 56 that is the keypress
;    bc is also the key press
;     d has a bit reset, the rest are set (this is the last key group tested)
;     e is a with a mask of %11111000
;    hl is not modified
;===============================================================
  di
  ld de,$FE00
  ld a,d
  out (1),a
  push af \ pop af
  in a,(1)
  ld b,e
  xor $FF \ jr z,+_
  ld d,a
  ld c,16 \ cp 15 \ ret z
  ld c,5
  ld a,3 \ and d \ cp 3 \ ret z \ inc c
  ld a,5 \ and d \ cp 5 \ ret z \ inc c
  ld a,10 \ and d \ cp 10 \ ret z \ inc c
  ld a,12 \ and d \ cp 12 \ ret z
  ld a,d
  cpl
  ld c,e
  jp key_add
_:
  ld c,a
_:
  rlc d
  ld a,d
  out (1),a
  inc e
  sub 7Fh
  jp z,CheckOnPress
  in a,(1)
  inc a
  jr z,-_
  dec a
key_add:
  inc c
  rra
  jr c,key_add
  ld a,e
  rlca \ rlca \ rlca
  add a,c
  ld c,a
  ret
CheckOnPress:
  call CheckStatus
  ret nz
  ld c,41
  ret
ElseToken:
;Check for an If token, maybe?
  push bc
  call FindEndToken
  call EndOfLine
  ld (parsePtr),hl
  pop bc
  ret
IfToken:
  push bc
  call ParseCondition
  ld a,b
  or c
  jr z,+_
  scf
_:
  pop bc
  ld hl,flags+gflags
  bit invlogic,(hl)
  jr z,+_
  res invlogic,(hl)
  ret nc
_:
  ret c
  ld hl,(parsePtr)
  inc hl
  ld a,(hl)
  push bc
  cp $CF    ;Then token
  call z,FindElseEnd
  cp $D0  ;Check if it was an Else token
  jr z,+_
  call EndOfLine
  ld (parsePtr),hl
  pop bc
  ret
_:
  ld (parsePtr),hl
  pop bc
  jp ParserNext
VarToken:
  call VarP
  ld (parsePtr),de
  ld c,(hl)
  inc hl
  ld b,(hl)
  ex de,hl
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  ld (parsePtr),de
  ld e,c
  ld d,b
  ld c,(hl)
  inc hl
  ld b,(hl)
  set FactorialFlag,(iy+InternalFlag)
  ret
ParseNextFullArg_Buffer:
;;Input: z flag
;;Result:
;;  z  : Parse the next argument, result in BC
;;  nz : Returns BC as the pointer to the main buffer
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  ld (gbuf_temp),bc
  ret
ParseNextFullArg:
  ld hl,(parsePtr)
ParseNextFullArg_Inc:
  inc hl
ParseNextFullArg_HL:
  ld (parsePtr),hl
ParseFullArg:
  bit FactorialFlag,(iy+InternalFlag)
  jr nz,+_
  ld de,0
_:
  res FactorialFlag,(iy+InternalFlag)
  ld hl,(parsePtr)
  ld a,(hl)
  call EndOArg
  ret z
  cp 29h
  ret z
  call ParseArg
  jr ParseFullArg
ParseCondition:
  call ParseArg
  ld hl,(parsePtr)
  ld a,3Fh
  cp (hl)
  jr nz,ParseCondition
  ret
GetNextVarNum:
  inc hl
  ld a,(hl)
  cp $AE
  jr nz,+_
  set Mod2nd,(iy+InternalFlag)
  ret
_:
  sub 3Ah
  add a,10
  ret nc
  ld a,d
  add a,a
  add a,a
  add a,d
  add a,a
  ld d,a
  ld a,(hl)
  and 15
  add a,d
  ld d,a
  jr GetNextVarNum
StoString:
  ld e,a
  ld d,(hl)
  inc d
  call GetNextVarNum
  dec d
  ld (parsePtr),hl
  ld h,b
  ld l,c
  push bc   ;Data in Grammer prg
  push de   ;D= Str Nr; E=AA
  call GetGrammerStr
  pop hl
  bit Mod2nd,(iy+InternalFlag)
  jr z,+_
  inc bc
_:
  push bc
  ld b,h
  ld c,l
  ld (OP1+1),hl
  xor a
  ld (OP1+3),a
  ld (OP1+1),bc \ rst rFindSym
  jr c,+_
;HL = pointer to the variable's Symbol Table entry
;DE = pointer to the variable's data structure
;B  = 0 for Ram, or Flashpage
;OP1=.db StrngObj,tVarStrng,tStr1,0,0; not all n�tig
  bcall(_DelVarArc)
_:
  pop hl  ;length
  push hl
  bcall(_CreateStrng)
  inc de
  inc de
  pop bc
  pop hl
  ldir
  bit Mod2nd,(iy+InternalFlag)
  ret z
  res Mod2nd,(iy+InternalFlag)
  dec de
  ld a,3Fh
  ld (de),a
  ret
StoDisp:
  ld (parsePtr),hl
  ld a,c
  ld b,0
  ld d,b
  ld e,b
  ld h,b
  ld l,b
  sub 6
  jr nc,+_
  ld a,c
  inc b
_:
  ld c,1
  or a
  jr nz,+_
  dec hl
  dec c
_:
  dec a
  jr nz,+_
  dec c
  ld hl,%1010101010101010
_:
  dec a
  jr nz,+_
  ld hl,%1001001001001001
_:
  dec a
  jr nz,+_
  ld hl,%1000100010001000
_:
  dec a
  jr nz,+_
  ld hl,%1000001000001000
_:
  dec a
  jr nz,+_
  ld hl,%1000000000001000
_:
  dec b
  jr nz,+_
  scf
  ex de,hl
  sbc hl,de
_:
  ld (GrayMask),hl
  ld hl,GrayRotate
  ld a,(hl)
  and $FC
  or c
  ld (hl),a
  ret
StoToken:
  ld a,(hl)
  inc hl
  cp $AA \ jp z,StoString
  cp $DE \ jr z,StoDisp
  cp $01 \ jr z,StoModule
  cp $3A \ jr z,StoFloat
  cp $2C \ jr nz,NotOSVar
  push bc
  ld a,(hl)
  ld (OP1+1),a
  inc hl
  ld (parsePtr),hl
  ld hl,0
  ld (OP1+2),hl
  ld h,b \ ld l,c
  bcall(_SetXXXXOP2)
  rst rFindSym
  jr nc,+_
  bcall(_CreateReal)
_:
  ld a,b
  or a
  jr nz,+_
  ld hl,OP2
  call mov9
_:
  pop bc
  ret
NotAVar:
  ld (parsePtr),hl
  ret
StoFloat:
  ld a,(hl)
  call VarP
  jr nc,NotAVar
  ld (parsePtr),de
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld h,b
  ld l,c
  jp mov4_page0
NotOSVar:
  call VarP
  jr nc,NotAVar
  push hl
  ld a,(de)
  ex de,hl
  inc hl
  call VarP
  jr c,+_
  dec hl
  ex de,hl \ pop hl
_:
  ld (hl),c
  inc hl
  ld (hl),b
  ld (parsePtr),de
  ret nc
  pop hl
  ld de,(ThetaPrimeVar)
  ld (hl),e
  inc hl
  ld (hl),d
  ret
StoModule:
  inc hl
  ld (parsePtr),hl
  ld hl,module_count
  ld a,(hl)
  cp 5
  jp nc,ErrPkgNotFound
  inc (hl)
  adc a,a
  add a,l
  ld l,a
  ld (hl),c
  inc hl
  ld (hl),b
  ret
Return:
  call EndOfLine
  ld c,l
  ld b,h
  ret
LblToken:
  push hl
  call ParseFullArg
  pop hl
  push bc
  call GetGrammerStr
  pop hl
  ld de,OP2
  push de
  ld a,3Ah
  ld (de),a
  inc de
  push bc
  ldir
  dec de
  ld a,3Fh
  ld (de),a
  ld hl,(parsePtr)
  ld a,(hl)
  cp 2Bh
  jr nz,+_
  inc hl
  ld (parsePtr),hl
  call GetVarInfo2
  jr nc,+_+3
_:
  ld hl,(progStart)
  ld a,3Fh
  pop bc
  inc bc
  pop de
  call SearchString
  ld b,h
  ld c,l
  ret
GotoToken:
  push bc
  call ParseFullArg
  ld (parsePtr),bc
  pop bc
  ret
DispGraph:
  ld a,(hl)
  ld hl,(BufPtr)
  call EndOArg
  jp z,GraphToLCD+3
  call ParseFullArg
  ld h,b
  ld l,c
  jp GraphToLCD+3
EndOArg:
  cp 4 \ ret z  ;->
EndOArgNotSto:
  cp 3Fh \ ret z ;NL
;  cp 3Ah \ ret z
  cp 3Eh \ ret z ;:
  cp 2Bh \ ret z ;,
  or a
  ret
;===============================================================
FindEndToken:
;===============================================================
;Input:
;     HL is an address
;Outputs:
;     HL points to the byte after the proper End token
;===============================================================
  ld b,1
SearchEndLoop:
  inc hl
  ld a,(hl)
  sub $CF                  ;Then
  jr c,SearchEndLoop       ;**Just to save time
  jr z,+_
  dec a
  dec a \ jr z,+_   ;While
  dec a \ jr z,+_   ;Repeat
  dec a \ jr z,+_   ;For
  dec a \ jr nz,SearchEndLoop ;End
  djnz SearchEndLoop
  inc hl
  ret
_:
  inc b
  jr SearchEndLoop
FindElseEnd:
;Input:
;     HL is an address
;Outputs:
;     HL points to the byte after the proper Else or End token
;     A is the last token checked
  ld b,0
FindElseEnd_:
  inc b
  inc hl
  ld a,(hl)
  sub $CF           ;Then
  jr c,-_+1
  jr z,-_
  dec a \ jr z,+_
  dec a \ jr z,-_   ;While
  dec a \ jr z,-_   ;Repeat
  dec a \ jr z,-_   ;For
  dec a \ jr nz,FindElseEnd_+1
_:
  djnz FindElseEnd_+1
  ld a,(hl)
  inc hl
  ret

;===============================================================
GetGrammerText:
;===============================================================
;Input:
;    HL points to the start of the string
;Outputs:
;     A is the value of the ending byte of the string
;    BC is the size of the string
;    DE points to the start of the converted string
;    HL points to the ending byte of the string
;     z flag is set
;===============================================================
  ld de,saveSScreen
GetGrammerText_DE:
  ld bc,0
  push de
TextConvert:
  ld a,(hl)
  cp 4   ;->
  jr z,TextConvertEnd
  cp 3Fh    ;newline
  jr z,TextConvertEnd
  cp 2Ah  ;"
  jr z,TextConvertEnd
  call TokToASCII+3
  jp TextConvert
  ld de,OP3
TokToASCII:
;Inputs:
;     HL points to the token
;     DE points to where the token should get converted to
;Outputs:
;     HL is incremented
;     DE points to the byte after the string
;     BC is the size of the string
  ld bc,0
  push hl
  push bc
  push de
  bcall(_Get_Tok_Strng)
  pop de
  pop hl
  add hl,bc
  push hl
  ld hl,OP3
  ldir
  pop bc
  pop hl
  ld a,(hl)
  call Is_2_Byte
  inc hl
  ret nz
  inc hl
  ret
TextConvertEnd:
  inc hl
  pop de
  ret
;;===============================================================
GetGrammerStr:
;;===============================================================
;;Input:
;;    HL points to the start of the string
;;Outputs:
;;     A is the value of the ending byte of the string
;;    BC is the size of the string
;;    HL points to the ending byte of the string
;;     z flag is set
;;===============================================================
  ld bc,0
_:
  inc hl
  inc bc
  ld a,(hl)
  cp 4 \ ret z
  cp 3Fh \ ret z
  cp 2Ah \ jr nz,-_
  inc hl
  ret
VarP:
  cp $AF    ;? token
  jr nz,VarPointer
  ex de,hl
  scf
  ld hl,qmarkVar
  ret
;===============================================================
VarPointer:
;===============================================================
;Inputs:
;     A is the var to return the pointer of
;     hl points to the next byte
;Outputs:
;     A is the lower 8-bits of the pointer
;     BC is not affected
;     DE should be used to update (parsePtr)
;     HL points to the var data
;     c flag is reset if A was not a var token
  cp $BB
  jr nz,NotBBvar
  ld d,h
  ld e,l
  ld a,(hl)
  sub 203
  ret nc
  sub -16
  adc a,10
;  cp 26       ;to be safe, we could include this
  ret nc
  add a,a
  ld hl,pvars+54
  add a,l
  ld l,a
#if (pvars+54)&255>=204
  jr nc,+_
  inc h
_:
#endif
  inc de
  scf
  ret
NotBBVar:
  cp 'A'
  ccf
  ret nc
  cp 'Z'+2
  ret nc
  sub 'A'
  rlca
  ld d,pvars>>8
  ld e,a
  ld a,(hl)
  cp $AE
  jr nz,+_
  ld a,54
  add a,e
  ld e,a
  inc hl
_:
  ld a,e
  add a,pvars&255
  ld e,a
#if pvars&255>=202
  jr nc,+_
  inc d
_:
#endif
  ex de,hl
  scf
  ret
;===============================================================
EndOfLine:
;===============================================================
;Input:
;     HL is a pointer
;Output:
;     HL points to the next line
;===============================================================
  ld a,3Fh
  push bc
  ld bc,0
  cpir
  pop bc
  ret
;===============================================================
IsHexTok:
;===============================================================
;Input:
;     DE points to the byte
;Output:
;     DE is incremented by 1
;      A is the hex value if A is a hex token
;     nc if A is a hex token
;      c if A is not a hex token
;===============================================================
  ld a,(de)
  inc de
  cp 47h
  ccf
  ret c
  cp 'A'
  jr nc,+_
  cp 3Ah
  ccf
  ret c
  .db $DA ;start of jp c,**
_:
  sub 7
  sub 30h
  ret
;===============================================================
ConvRStr:
;===============================================================
;Input:
;     DE points to the base 10 number string in RAM.
;Outputs:
;     HL is the 16-bit value of the number
;     DE points to the byte after the number
;     BC is HL/10
;     z flag reset (nz)
;     c flag reset (nc)
;Destroys:
;     A (actually, add 30h and you get the ending token)
;Size:  41 bytes
;Speed: 134+(106+{0,9})n
;       n is the number of digits
;       c is at most n-2
;       at most 691 cycles for any 16-bit decimal value
;===============================================================
  dec hl
  bit baseInput,(iy+UserFlags)
  jp nz,ConvHexStr
  ex de,hl
  ld hl,0
  push de   ;save in case we encounter a float
_:
  ld a,(de)
  sub 30h
  cp 10
  jr nc,+_
  inc de
  ld b,h
  ld c,l
  add hl,hl
  add hl,hl
  add hl,bc
  add hl,hl
  add a,l
  ld l,a
  jr nc,-_
  inc h
  jp -_
_:
  jr z,+_   ;means it was a decimal point
  pop bc
  ld (parsePtr),de
  ld b,h
  ld c,l
  ret
_:
  pop hl
  ;HL points to the string
  dec hl
  ld a,(hl)
  cp $B0     ;neg sign token
  jr nz,+_
  ;Need to pop off the return address; not returning to the neg routine
  pop de
  pop de
  .db $FE   ;start of cp *, causes the inc hl to be ignored
_:
  inc hl
  ;HL points to the float
  push hl
  call floatstackpush
  ld b,h
  ld c,l
  ld hl,str2single
  ld (next_page_call_address),hl
  pop hl
  call next_page_call
  ld hl,(ptr_sto)
  ld (parsePtr),hl
  ret
;===============================================================
HL_Div_BC:
;===============================================================
;Performs HL/BC
;Speed:   1182cc (+6cc for every 0bit in the result)
;Size:    29 bytes
;Inputs:
;     DE is the numerator
;     BC is the denominator
;Outputs:
;     HL is the quotient
;     DE is the remainder
;     BC is not changed
;     z flag is set
;     c flag is reset
;===============================================================
  ex de,hl
;===============================================================
DE_Div_BC:
;===============================================================
;Performs DE/BC
;Speed:   1178cc (+6cc for every 0bit in the result)
;Size:    28 bytes
;Inputs:
;     HL is the numerator
;     BC is the denominator
;Outputs:
;     HL is the quotient
;     DE is the remainder
;     BC is not changed
;     z flag is set
;     c flag is reset
;===============================================================
  ld a,e
  ld e,16
  ld hl,0
Div16Loop:
  rla
  rl d
  adc hl,hl
  sbc hl,bc
  jr nc,+_
  add hl,bc
_:
  dec e
  jr nz,Div16Loop
  rla
  cpl
  ld e,a
  ld a,d
  rla
  cpl
  ld d,a
  ex de,hl
  ret
#include "cmd/searchstring.z80"
;===============================================================
CheckStatus:
;===============================================================
;Speed:  89 cycles
;Size:   13 bytes
;Outputs:
;     z is set if ON is being pressed
;     c is set if 15MHz mode is used
;===============================================================
  push bc
  push af
  in a,(4)
  and 8
  in a,(20)
  rra
  pop bc
  ld a,b
  pop bc
  ret
sqrtHL_page0:
;returns HL as the sqrt, DE as the remainder
	ld	a,l
	ld	l,h
	ld	de,$0040
	ld	h,d
	ld	b,8
	or	a
sqrtHL_loop:
	sbc	hl,de
	jr	nc,+_
	add	hl,de
_:
	ccf
	rl	d
	rla
	adc	hl,hl
	rla
	adc	hl,hl
	djnz	sqrtHL_loop
  ld e,h
  ld l,d
  ld h,b
  ld d,b
  rl d
	ret
SetMem:
  ld (hl),a
  ld d,h
  ld e,l
  cpi
  ret po
  ex de,hl
  ldir
  ret
;===============================================================
Is_2_Byte:
;===============================================================
  cp $EF \ ret z
  cp $BB \ ret z
  cp $7E \ ret z
Is_Var_Name:
  sub $AA \ ret z     ;AA
  add a,$47 \ ret z   ;63
  inc a \ ret z
  inc a \ ret z
  inc a \ ret z
  add a,2 \ ret z
  inc a \ ret z
  inc a \ ret
ConvOP1:
  ld hl,OP1
convFloat:
;Inputs: HL points to the TI Float.
;Outputs: The float is converted to a 16-bit integer held in DE, or LSB in A.
;68cc if not a number
;93cc          on (0,1)
;154.140625cc  on [1,10) or 0
;324.5159375cc on [10,100)
;435.6565625cc on [100,1000)
;540.031875cc  on [1000,10000)
;651.1725cc    on [10000,100000)
;118cc         if >=100000
;Average for integers on [0,65535]: ~632.43cc
  call +_
  ld a,e
  ret
_:
  xor a
  ld d,a
  ld e,a
  or (hl)
  and 31
  ret nz
  inc hl
  ld a,(hl)
  sub 80h
  ret c
  inc hl
  jr z,lastdigit2
  cp 5
  ret nc
  ld b,a

_:
  ;multiply DE by 100
  ex de,hl
  ld a,b
  sla l
  add hl,hl
  ld b,h
  ld c,l
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,bc
  ex de,hl
  ld b,a
  call convBCDbyte
  inc hl
  dec b
  ret z
  djnz -_
lastdigit:
  ex de,hl
  ld b,h
  ld c,l
  add hl,hl
  add hl,hl
  add hl,bc
  add hl,hl
  ex de,hl
lastdigit2:
;49+{0,8
;min: 49cc
;max: 57cc
;avg: 49+8*4.5/256 = 49.140625
  ld a,(hl)
  rrca
  rrca
  rrca
  rrca
  and 15
  add a,e
  ld e,a
  ret nc
  inc d
  ret
convBCDbyte:
;min: 60cc
;max: 68cc
;avg: 60+8*(99*98/2/100)/256 = 61.5159375cc
  ld a,(hl)   ;\ I feel particularly proud of this code, so feel free to use it ^~^
  and $F0     ; |It converts a byte of BCD to an 8-bit int.
  rra         ; |The catch is, I only have A and C to use, and (hl) is the BCD
  ld c,a      ; |number.
  rra         ; |If you come up with faster, please let me know and post it in
  rra         ; |the optimized routines thread on popular TI forums.
  sub a,c     ; |Algo: Multiply upper digit by -6, add the original byte.
  add a,(hl)  ;/ Result is upper_digit*(-6+16)+lower_digit. Ha, repost.
  add a,e
  ld e,a
  ret nc
  inc d
  ret
ConvHexTo86ECh:
;max: 174n+91
;min: 128n+56
;avg: 145.25x+79    (typical avg, assuming most end in newline)
;An 8x8 sprite is now 6% faster on avg. than versions <2.50
  ld d,b
  ld e,c
  ld hl,86ECh
  ld bc,$0A30
ConvHexLoop7:
;  HL points to where to convert
;  DE is where to convert from
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  inc hl
  jp ConvHexLoop7
IsConditional:
  cp $D8 \ ret z      ;pause
  cp $CE \ ret z      ;if
  cp $D1 \ ret z      ;while
  cp $D2 \ ret        ;repeat
SetUpData:
  bcall(_RunIndicOff)
  call setupRAMdata
#ifndef include_TSA
  ld hl,ReadArcData
  ld de,TSA
;mov 70 bytes
  call mov14
  call mov14
  call mov14
  call mov14
  call mov14
  in a,(6)
  ld (page_restore),a
  ld (bincomparepagerestore),a
#ifdef include_interrupt
  dec a
  ld (interrupt_page),a
#endif
#endif

;initialize the float rand routine
  ld hl,randinit
  ld (next_page_call_address),hl
  call next_page_call

  ld hl,floatstack_bottom
  ld (floatstack_ptr),hl
  ld hl,seed2+1
  set 6,(hl)
  dec l
  dec l
  ld a,r \ xor (hl) \ ld (hl),a
  ld hl,plotSScreen
  ld (BufPtr),hl
  ld (GrayBufPtr),hl
  ld hl,PBuf
  ld (PBufPtr),hl
  ld hl,766
  ld (PBuf),hl
  ld a,3
  ld (OutputLogic),a
  ld (TextPauseTime),a
  ld hl,FontSet
  ld (FontPointer),hl
  xor a
  ld (module_count),a
  ld h,a
  ld l,a
  ld (flags+33),hl
  ld (flags+34),hl
  ld (IntLoc),hl
  ld (PBufType),hl
  ld (GrayRotate),hl
  ld hl,5555h
  ld (GrayMask),hl
  pop hl
  ld (SPSave),sp
  jp (hl)
setupRAMdata:
;not speed critical
  ld de,8100h
  ld hl,RAMCodeStart
  ld bc,RAMCodeEnd-RAMCodeStart
  ldir
  ret
EraseParticle:
  ld c,(hl)
  inc hl
  ld b,(hl)
;pixel off
  push bc
  call GetPixelLoc
  pop bc
  ret
TokenSet:
#ifdef include_LoadTSA
#include "cmd/loadtsa.z80"
#endif
isStartMenu_valid:
  ld a,(OP1+1)
  cp $23
  jr z,StartMenu_invalid
  cp $21
  jr z,StartMenu_invalid
  ld hl,(VATPtr)
  ld a,(hl)
  cp 1        ;don't want lists
  jr nz,+_
StartMenu_invalid:
  or a
  ret
_:
  cp 13       ;don't want complex lists
  jr z,StartMenu_invalid
  cp 17h      ;don't want GroupVars
  jr z,StartMenu_invalid

  bit 6,(iy+UserFlags)     ;must be AppV
  jr z,+_
  cp 15h
  ret nz
_:
;need to pull in six bytes
#ifdef include_LoadTSA
  call LoadReadArc
#endif
  ld bc,-3
  add hl,bc
  ld e,(hl)
  dec hl
  ld d,(hl)
  dec hl
  ld a,(hl)
  or a
  jr z,+_
  ld b,a
  dec hl
  ld a,(hl)
  add a,10
  add a,e
  ld e,a
  ld a,b
  jr nc,+_
  inc d
  jp po,+_
  inc a
  ld d,$40
_:
  ex de,hl
  ld de,cmdShadow
  ld bc,2
  call TSA
  ld bc,(cmdShadow)
  ;need to save A:HL, BC
  ld (TempWord3),a
  ld (TempWord4),bc
  ld (TempWord5),hl
_:
  ld bc,4
  call TSA
  ld hl,cmdShadow+2
  bit OnBlockFlag,(iy+UserFlags)   ;ASM only
  jp nz,asm_header_only
;non-ASM and ASM alike
  bit baseInput,(iy+UserFlags)
  ret z   ;doesn't have any special filters
;must be a Grammer Var
;header is either $BB,$6D,$55,$C9 or $3A,$30,$3E
  ld a,(hl) \ cp $BB \ jr z,+_
  cp $3A \ ret nz
  inc hl \ ld a,(hl) \ cp $30 \ ret nz
  inc hl \ ld a,(hl) \ cp $3E \ ret
_:
  inc hl \ ld a,(hl) \ cp $6D \ ret nz
  inc hl \ ld a,(hl) \ cp $55 \ ret nz
  inc hl \ ld a,(hl) \ cp $C9
  ret
asm_header_only:
;first two bytes must be $BB,$6D
;
  ld a,(hl) \ cp $BB \ ret nz
  inc hl \ ld a,(hl) \ cp $6D \ ret nz
  bit baseInput,(iy+UserFlags)
  ret z
;next two bytes must be $55,$C9
;
  inc hl \ ld a,(hl) \ cp $55 \ ret nz
  inc hl \ ld a,(hl) \ cp $C9
  ret
CompatCall:
  call setupRAMdata
IsOP1GrammerProg:
  ld (iy+UserFlags),8
  bcall(_ChkFindSym)
  ld (VATPtr),hl
  jp nc,isStartMenu_valid
  or 1
  ret
#ifdef include_LoadTSA
ReadArc:
  call LoadReadArc
  jp TSA
#else
ReadArc = TSA
#endif
ReadArcData:
#ifdef include_loadTSA
  .dw ReadArcEnd-ReadArc-2
#endif
#include "readarc.z80"
ReadArcEnd:
FindGVarData:
  ld hl,GVarData
  rst rMov9ToOP1
  bcall(_ChkFindSym)
  ret nc
  ld hl,3
  bcall(_CreateAppVar)
  ret
GrammerHook:
  .db 83h
  or a
  jr nz,exithook3
  di
  push hl
  push de
  push bc
  push af
  ld de,(progstart)
  ld a,(de)
  cp $5F      ;make sure it is the prgm Token. I just realized that in older versions, you could have any 1-byte token instead of the prgm token!
  jr z,+_
exithook1:
  pop af
  pop bc
  pop de
  pop hl
exithook3:
  cp a
  ret
_:
  ld hl,(progend)
  sbc hl,de
  inc de
  ld b,h
  ld c,l
  ld a,h
  or a
  jr z,+_
  ld bc,8
_:
  ld a,c
  or a
  jr z,exithook1
  cp 9
  jr c,+_
  ld c,8
_:
  ex de,hl
  ld de,OP1
  ld a,5
  ld (de),a
  inc de
  ldir
  xor a
  ld (de),a
  call SetUpData
  call IsOP1GrammerProg
  jr nz,+_
  ld hl,OP1
  ld de,OP5
  call mov9
  pop af
  pop bc
  pop de
  pop hl
  call SelectedProg
  or 1
  ret
_:
  ld hl,cmdShadow+2             ;location of header
; ION =BB6DC918
; MOS =BB6DC901
; DCS7=BB6DAAC9
; Gram=BB6D55C9
  ld a,(hl) \ cp $BB \ jp nz,HookEnd
  inc hl \ ld a,(hl) \ cp $6D \ jp nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9 \ jp z,MOSIONErr
  ld c,a
  inc hl \ ld a,(hl) \ cp $C9 \ jp nz,HookEnd
  ld a,c \ cp $AA \ jp z,DCSErr
#ifdef SHELL_BROKEN
  jp GramErr
#endif
HomeRunASM:

  ld hl,(TempWord5) \ ld bc,(TempWord4)
  jr nz,+_
  inc hl \ inc hl \ dec bc \ dec bc
_:
  inc hl \ inc hl \ dec bc \ dec bc
  ld de,9D94h
  or a \ sbc hl,de
  add hl,de
  ld de,OP1
  jr nz,+_
  pop hl \ pop hl \ pop hl \ pop hl
  xor a
  ret
_:
  ldir
  xor a
  ld (de),a
  ld a,5
  ld (OP1),a
  call SetUpData+3
  call IsOP1GrammerProg
  jr nz,EndHook

  ld hl,OP1
  ld de,OP1+44
  call mov9
  pop af
  pop bc
  pop de
  pop hl
  call SelectedProg
  or 1
  ret
EndHook_prepush:
  push af
  push af
  push af
  push af
EndHook:
  ld hl,cmdShadow+2             ;location of header
; ION =BB6DC918
; MOS =BB6DC901
; DCS7=BB6DAAC9
; Gram=BB6D55C9
  ld a,(hl) \ cp $BB \ jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $6D \ jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9
  jr z,HookEnd
  ld a,55h
  cp (hl)
  jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9
  jr c,+_
  add hl,bc
_:
  push hl \ push bc
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
;HL # bytes
;DE addr
  ld de,9D95h ;start VarRAM
  push de
  bcall(_InsertMem)
  pop de \ pop bc \ pop hl
  ld a,(TempWord3)
  push de \ push bc
  call ReadArc
  ld hl,0
  add hl,sp
  ld (SPSave),hl
  call 9D95h ;start VarRAM
  pop de \ pop hl
;Delmem: HL address
;        DE # of bytes
  bcall(_DelMem)
;===============================================================
  or 1
;HookEnd-6 Label ------ !!!!
  pop hl
  ld a,h
  pop bc
  pop de
  pop hl
  ret
HookEnd:
  xor a
  jr HookEnd-6
GetVarName:
  call ParseFullArg
  ld h,b
  ld l,c
GetVarName_:
  ld a,(hl)
  and 1Fh
  ld de,OP1
  sub 5 \ jp z,GetGrammerText+3
  dec a \ jp z,GetGrammerText+3
  sub 15 \ jp z,GetGrammerText+3
  dec a \ jp z,GetGrammerText+3
  ld bc,3
  ld d,h \ ld e,l
  add hl,bc
  cp a
  ret
GetVarInfo:
;Returns name in OP1
;A is the flashpage
;HL points to SymEntry
;DE points to size bytes
;BC is the length of the name (for use when finding archived data)
;nc if it exists
;z if it is in RAM
  call GetVarName
GetVarInfo_:
  ex de,hl
  ld de,OP1
  push bc
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
  ld a,b
  pop bc
  ret c
  or a
  ret
GetvarInfo2:
;Inputs:
;     The next argument to parse points to the name of the var to get info about
;Outputs:
;     A is the ending page (start of data)
;     BC is the size of the var
;     DE points to the SymEntry
;     HL points to the data
;     c is set if the var does not exist
#ifdef include_LoadTSA
  call LoadReadArc
#endif
  call GetVarInfo
  ret c
GetVarInfoVarFound:
  ex de,hl
  or a
  jr nz,+_
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ret
_:
  add hl,bc
  ld c,9
  add hl,bc
  bit 7,h
  jr z,+_
  ld h,40h
  inc a
_:
  push de
  ld de,OP2
  ld bc,2
  call TSA
  ld bc,(OP2)
  pop de
  or a
  ret
;=====================================================
TileMap1:
;=====================================================
;Inputs:
;     DE=MapLoc
;     BC=TileLoc
;     HL=MapWidth
;     A=TileLogic
;     (TempWord2)=Map X
;     (TempWord3)=Map Y
;=====================================================
  and 7
  ld (TempWord1),a
  cp 7
  jr nz,+_
  ld a,(flags+33)
  xor 16
  ld (flags+33),a
_:
  push bc
  push hl
  push de
  ld bc,(TempWord3)
  call HL_Times_BC
  ld bc,(TempWord2)
  add hl,bc
  pop bc \ add hl,bc
  ex (sp),hl ;edited in 2.50.0.2
  ld de,-12  ;
  add hl,de  ;
  pop de     ;
  ld (TempWord2),hl
  xor a
  ld (TempWord1+1),a
  pop bc
;DE points to first Map Element
;(TempWord2) is the map width thing
;BC points to the sprite data
TileMap1loop:
  ld h,12
  ld a,(de) \ inc de
  dec h
  jr nz,DrawNextTile
  ld hl,(TempWord2)
  add hl,de
  ex de,hl
  ld h,12
DrawNextTile:
  push hl
  ld h,0 \ ld l,a
  add hl,hl
  add hl,hl
  add hl,hl
  ld a,(TempWord1)
  cp 7
  jr nz,+_
  add hl,hl
_:
  add hl,bc
  ld a,(TempWord1+1)
  call DrawTile
  ld (TempWord1+1),a
  pop hl
  jr nz,TileMap1Loop+2
  ret
DrawTile:
;Input:
;     A is the tile number to draw
;     HL points to the sprite data
;Output:
;     A is incremented by 1
;     BC is not changed
;     DE is not changed
;     HL is not changed
;     z flag set if A is 96
; jr $
  sub 96
  ret nc
  push af
  push hl
  push de
  push bc
  ex de,hl
;DE points to sprite
  ld hl,(BufPtr)
  inc h
  inc h
  inc h
  ld bc,-96
_:
  add hl,bc
  add a,12
  jr nc,-_
  ld c,a
  inc b
  add hl,bc
  ld bc,0108h
  ld a,(TempWord1)
  call DrawSpriteXxY
  pop bc
  pop de
  pop hl
  pop af
  add a,97
  ret
OmniCalcFont:
;Inputs:
;    B is the char to draw
  ld l,b
  ld h,0
  ld b,h
  ld c,l
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,bc
  ld bc,(FontPointer)
  add hl,bc
  ld de,OP1
  ld b,7
_:
  ld a,(hl)
  rlca
  rlca
  rlca
  ld (de),a
  inc e
  inc hl
  djnz -_
  ld de,OP1
  ld hl,0706h
  jr VputSCStepIn
VPutSC:
;Inputs:
;    B is the char to draw
  ld a,b
  cp 20h
  ld hl,(FontPointer)
  ld c,b
  ld b,0
  add hl,bc
  add hl,bc
  add hl,bc ;*3
  ld de,OP1
  ld b,3  ;3*2 Nibbles
_:
  ld a,(hl)
  and $F0
  ld (de),a
  inc e
  ld a,(hl)
  rrca \ rrca
  rrca \ rrca
  and $F0
  ld (de),a
  inc e
  inc hl
  djnz -_
  ld de,OP1
  ld hl,0604h
  jr VputSCStepIn
VPutC:
;Inputs:
;    B is the char to draw
  ld hl,(FontPointer)
  ld de,255
_:
  inc e
  add hl,de
  ld a,(hl)
  ;a is w,h in nibbles
  and 15 ;height
  inc a  ;1..16 is enough
  ld e,a
  djnz -_
  ld d,e  ;height->d
  ld e,(hl) ;now width
  srl e \ srl e
  srl e \ srl e ;->low nibble, width 0..9
  inc hl
  ex de,hl
VputSCStepIn:
  push hl
  ld bc,(TextRow)
  ld a,b \ add a,l
  cp 97
  jr c,+_
  ld a,c
  add a,h \ ld c,a
  ld a,l \ ld b,0
_:
  ld l,a
  ld a,c
  cp 58
  jr c,+_
  xor a
  ld c,a
_:
  ld h,l
  ld l,a
CoordAdj:
  ld (TextRow),hl
  pop hl
  ld a,(OutputLogic)
  jp sprite
SearchLine:
;Inputs:
;     HL points to the start
;     BC is the number of bytes to search
;     DE is the line number
;     A is the line byte
;Outputs:
;     A is not changed
;     BC is the number of bytes left for the search
;     DE points to the line
;     HL is the length of the line
;===============================================================
  inc bc
  dec de \ inc d \ inc e
  or a
_:
  ld (TempWord1),hl
  cpir
  jp po,+_
  dec e \ jr nz,-_
  dec d \ jr nz,-_
_:
  scf
  ld de,(TempWord1)
  sbc hl,de
  ret

GPutSI:
;     The string to display immediately follows the call
;       The string is zero terminated
;Outputs:
;     All registers are preserved
  ex (sp),hl
  push de
  push bc
  push af
  call GPutS
  inc hl
  pop af
  pop bc
  pop de
  ex (sp),hl
  ret
DrawRectToGraphI:
  ex (sp),hl
;  push de \ push bc \ push af
  ld e,(hl) \ inc hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ld a,(hl) \ inc hl
  ex (sp),hl
  jp DrawRectToGraph
ExecLine_:
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  push de
  push hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  call ParseNextFullArg_HL
  ld de,(parsePtr)
  pop hl
  inc de
  ld (hl),e
  inc hl
  ld (hl),d
  pop hl
  ld (parsePtr),hl
  ret
ExecLine:
  call ParseFullArg
  push bc
  cp 2Bh
  ld bc,(ProgStart)
  call z,ParseNextFullArg
  push bc
  ld bc,32768
  cp 2Bh
  call z,ParseNextFullArg
  push bc
  cp 2Bh
  ld bc,63
  call z,ParseNextFullArg
  ld a,c
  pop bc
  pop hl
  pop de
  call SearchLine
  ld b,d
  ld c,e
  jp g_expr
Byte:
  ld b,0
  ld c,(hl)
  inc hl
  ld (parsePtr),hl
  ret
Word:
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (parsePtr),hl
  ret
NegRelPtr:
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (parsePtr),hl
  ld hl,(progEnd)
  or a
  sbc hl,bc
  ld b,h
  ld c,l
  ret
Base2Num:
  ld bc,0
  ld d,b
  ld e,c
_:
  ld a,(hl)
  sub '2'
  add a,2
  jr nc,+_
  rrca
  rl c
  rl b
  rl e
  rl d
  inc hl
  jp -_      ;It saves 2 cycles using JP D:
_:
  set FactorialFlag,(iy+InternalFlag)
  ld (parsePtr),hl
  ret
_:
  ld hl,lnSingle
  jp float_stepin_1
LnToken:
  ld a,(hl)
  cp 3Ah
  jr z,-_
  cp $B0
  push bc
  jr z,JumpBack
  call ParseFullArg
  ld d,b \ ld e,c
  ld bc,0
_:
  ld a,3Fh
  cpir
  dec de
  ld a,d \ or e
  jr nz,-_
  ld (parsePtr),hl
  pop bc
  ret
JumpBack:
  call ParseNextFullArg
  ld d,b \ ld e,c
  dec hl
  ld bc,0
  inc de
_:
  ld a,3Fh
  cpdr
  dec de
  ld a,d \ or e
  jr nz,-_
  ld (parsePtr),hl
  pop bc
  ret
GetByte:
  ld d,3
  ld bc,-1
  xor a
  out (0),a
  in a,(0)
  xor d
  ret z
  ld bc,0800h
_:
  in a,(0)
  bit 1,a
  jr nz,-_
  out (0),a
  rra
  rl c
  djnz -_
  ret
SendByte:
;E is the byte to send
;BC is the wait length
  ld a,3
  out (0),a
  ld d,a
_:
  in a,(0)
  and d
  jr nz,+_
  dec bc
  ld a,b
  or c
  jr nz,-_
  dec bc
  ret
_:
  ld b,8
SendByteLoop:
;E is the byte to send
;D is the mask
  xor a
  rlc e
  jr c,+_    ;could use rla
  inc a
_:
  out (0),a
  djnz SendByteLoop
  xor a
  out (0),a
  ld c,a
  ret
cmdJmp:
#if (CommandJumpTable&255)=0
  ld h,CommandJumpTable>>8
  add a,a
  jr nc,+_
  inc h
_:
  ld l,a
#else
  ld hl,CommandJumpTable
  add a,a
  jr nc,+_
  inc h
_:
  add a,l
  ld l,a
  jr nc,+_
  inc h
_:
#endif
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  push hl
  ld hl,(parsePtr)
  ret
menu:
  ld hl,(parsePtr)
  ld (TempWord1),hl
  ld hl,OP3
  ld (parsePtr),hl
  ld (hl),$E6
  inc hl
  ld (hl),0
  jp module
DrawRectToGraph:
  push hl
  ld hl,drawrect
  ld (next_page_call_address),hl
  pop hl
  jp next_page_call
#include "main.z80"
#include "progmeta.z80"
#include "compile.z80"
#include "module.z80"
#include "ramcode.z80"
#include "routines.z80"
#include "math.z80"
#include "tokenhook.z80"
#include "cmd/particle.z80"
#include "gfx/text.z80"
#include "gfx/circle.z80"
#include "gfx/gbufToLCD.z80"
#include "gfx/getpixelloc_nobound.z80"
#include "gfx/GetPixelLoc.z80"
#include "math/mul16.z80"
#include "subroutines/diRestore.z80"
#include "err.z80"
#include "data.z80"
.echo "Page 0: ",$8000-$," bytes remaining"

.fill $8000-$,255
#include "01.z80"


.echo "RamCode : ",RamCodeEnd-RamCodeStart
