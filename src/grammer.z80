;Grammer
;================:
;\\     /\       :
; \\   //\\      :
;  \\ //  \\     :
;   \\/----\\    :
;   //\----//\   :
;  // \\  // \\  :
; //   \\//   \\ :
;//     \/     \\:
;================:
;Project.........Grammer
;Program.........Grammer
;Author..........Zeda Elnara (ThunderBolt)
;E-mail..........xedaelnara@gmail.com
;Size............
;Language........English
;Programming.....Assembly
;Version.........V2Ac.14.5.16
;Last Update.....6:45 AM 5/22/2012 ;not now

#define bcall(x) rst 28h \ .dw x
#define LCDDelay()   in a,(16) \ rla \ jr c,$-3
;#define rotatemask() sla c \ jr nc,$+4 \ set 2,c    ;ld a,c \ cp $C0 \ rra \ ld c,a
#include "grammer.inc"
#define Coord(y,x)     .db 01,y,x
#define SHELL_BROKEN
;#define speed
;for x,y,$ffff never stops
;Sqrt:' 255->0 Error
;"Rect(" is sometimes Line(
#define K_DELAY_DEFAULT 13
#define K_DELAY_ACCEL 3
;#define include_fire
;#define include_prime
;#define include_ncr
;#define include_LoadTSA
;#define include_interrupt

.org $4000
.db $80,$0F, 0,0,0,0
.db $80,$12, $01,$04    ;signing key ID
.db $80,$47, "Grammer" ;change the $47 according to name len.
.db $80,$81, 1          ;num pages
.db $80,$90             ;no splash
.db $03,$22,$09,$00     ;date stamp
.db $02,$00             ;date stamp signature
.db $80,$70             ;final field

     jp main
jumptable:
#include "jmptable.z80"
#ifdef include_interrupt
.echo $4040-$," bytes before interrupt jump"
#if $4040<$
.echo "Alert!!! Interrupt jump is in the wrong place!"
#else
.fill $4040-$,255
#endif
#include "interrupt.z80"
.echo $4100-$," bytes before interrupt jump"
#if $4100<$
;need to shorten interrupt, possibly put in a jp instead of actual code
.echo "Alert!!! Interrupt table is in the wrong place!"
.echo "no interrupt table"
#else
.fill $4100-$,255
.fill $4201-$,$40
#endif
#endif
main:
  call SetUpData
  call StartMenu
  xor a
  ld (kbdScanCode),a
_:
  call GetKey
  or a
  jr nz,-_
	bcall(_clrTxtShd)
  bcall(_saveCmdShadow)
  bcall(_JForceCmdNoChar)
StartMenu:
  ld bc,0
  ld (TempWord3),a
  ld (TempWord4),bc
  ld (TempWord5),hl
  call FindGVarData
  ld a,b \ or a
  jr nz,+_
_:
  in a,(6)
  ld hl,GrammerHook
  bcall(_SetParserHook)

;======
  jp startmenu__
SelectedProg:

  ld de,OP1
  ld hl,OP5
  call mov9
SelectedProgOP1:
  ld hl,gbuf
  ld (BufPtr),hl
  bcall(_ChkFindSym)
  ret c
  ld hl,cmdShadow+2
  ld a,$BB
  cp (hl)
  jr nz,+_
  inc l
  ld a,$6D
  cp (hl)
  jr nz,+_
  push af
  push af
  push af
  push af
  jp EndHook
_:
  ld a,(TempWord3)
  or a
  jp z,ExecOP1
;Here we need to move the code to RAM.
;  We will perform some minor pre-compiling
;  by evaluating labels
  ld hl,GramTempName
  rst rMov9ToOP1
  ld hl,(TempWord4)
  ld a,h \ or l
  ret z
 bcall(_MemChk)
 ld bc,-20     ;at some point I have to actually calculate this
 add hl,bc
 jp nc,err_LowMem
 ld de,(TempWord4)
 ;check if there is enough room to at least copy the program
 or a
 sbc hl,de
 jp c,err_LowMem
 add hl,de

  ld a,16h
 ld (size_of_buffer),hl
  bcall(_CreateVar)
  inc de \ inc de
  ld a,(TempWord3)
  ld bc,(TempWord4)
  ld hl,(TempWord5)
 ld (start_of_prog),de

  call ReadArc
 ld (end_of_prog),de
;instead of the ReadArc, we need to stream in bytes, building a table of various pointers and converting numbers.
;If the numbers are 1 digit, the output will be larger :(
;If the numbers are 2 digits, the output will be the same size :|
;If the number is 3 digits, less than 256, the output will be smaller! (3 digits, but >=256 is same size :|)
;All other numbers will be more compact!
;
;When a comment/label is parsed, we need to instead copy it to an LUT at the back, along with the address where it would be inserted.
;If the "Lbl " command is come across, first search for if the label has already found.
;  If yes, just replace it with a pointer value
;  If no, then store a pointer of 0x0000, and in another LUT, if the name does not exist yet, add it along with the address, else append the address to it.
;Move Strings to the data section
;
;Parse through the source, looking for '.' or 'Lbl ' (0x3A and 0xD6, respectively)
 ld de,(start_of_prog)
 ld hl,(size_of_buffer)
 add hl,de
 ld (end_of_buffer),hl
 ld (stack_top),hl
 ld h,d
 ld l,e     ;read_head, DE is write_head
 ld bc,(TempWord4)
;end_of_prog
;end_of_buffer
;stack_top
;size_of_buffer
;start_of_prog
_:
  ld a,(hl)
  cp $3A
  call z,pushlabel
  cp $D6
  call z,findlabel
  ldi
  jp pe,-_

;Now we need to deallocate unused RAM
;
 ld hl,(start_of_prog)
 ex de,hl
 or a
 sbc hl,de
 ex de,hl
 dec hl
 ld b,(hl)
 ld (hl),d
 dec hl
 ld c,(hl)
 ld (hl),e
;Now we need to get rid of BC-DE bytes at HL+DE+2
 add hl,de
 inc hl
 inc hl
;Now we need to get rid of BC-DE bytes at HL
 ld a,c
 sub e
 ld e,a
 ld a,b
 sbc a,d
 ld d,a
;Now we need to get rid of DE bytes at HL
 bcall(_DelMem)
  ld hl,OP4
  rst rMov9ToOP1
  jr ExecOP1
ProgramAccessStart:
  bcall(_RclAns)
  sub 4
  jr nz,grazh
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld de,OP1
  ldir
  ld (de),a
ExecOP1:
  ld hl,OP1
  ld de,basic_prog
  call mov9
  bcall(_ChkFindSym)
  ld a,b
  ret c
  or a \ ret nz
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
parse_via_ptr:
;HL points to code
;BC is the size
  ld (parsePtr),hl
  ld (progStart),hl
  add hl,bc
  ld (progEnd),hl
  ld h,a \ ld l,a
  ld (parseError),hl
grazh:
#ifdef include_interrupt
  di
  ld a,11
  out (3),a
  ld a,6
  out (4),a   ;set slowest hardware timer mode
  ld a,41h
  ld i,a
  im 2
  ei
#endif
  call SetUpData
  call progmeta
  ld hl,BreakProgram
  push hl
ParserNext:
  bit IntActiveFlag,(iy+InternalFlag)
  jr nz,NoInt
  ld hl,(IntLoc)
  ld a,h \ or l
  jr z,NoInt
  ex de,hl
  ld hl,(IntCount)
  dec l
#ifdef include_fire
  jr nz,NoFire
  dec h
  jr nz,NoFire
  ld hl,(parsePtr)
  push hl
  ld (parsePtr),de
  set IntActiveFlag,(iy+InternalFlag)
  push bc
  call ParserNext
  pop bc
  pop hl
  ld (parsePtr),hl
  ld hl,(IntMax)
NoFire:
  ld (IntCount),hl
  res IntActiveFlag,(iy+InternalFlag)
#endif
NoInt:
  bit OnBlockFlag,(iy+UserFlags)
  call z,CheckStatus
  call z,ONErr
  ld de,ParserNext
  push de
ParseArg:
  ld hl,(BufPtr)        ;wtf is going on here?
  ld (BufPtr0e),hl
  ld hl,(parsePtr)
ParseArg2:
  bit IntActiveFlag,(iy+InternalFlag)
  jr nz,$+3
  ei
  ld a,(hl)
  inc hl
  ld (parsePtr),hl
#if (CommandJumpTable&255)=0
  ld h,CommandJumpTable>>8
  add a,a
  ld l,a
  rra
  jr nc,$+3
  inc h
#else
  ld e,a
  ld hl,CommandJumpTable
  ld d,0
  add hl,de
  add hl,de
#endif
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  ld hl,(parsePtr)
  ret
NewLine:
  ld (Ans),bc
IncPtr:
Ret:
  ret
#ifdef include_prime
FracToken:
  ld h,b \ ld l,c
  call PrimeTest
  ld b,0
  ld (ThetaPrimeVar),bc
  ld b,h \ ld c,l
  ret
#endif
OutputToken:
  ld a,(hl)
  cp 11
  jr nz,+_
  call ParseNextFullArg
  ld a,c
  ld (OutputLogic),a
  ret
_:
  call ParseFullArg
  ld de,GrayRotate
  ex de,hl
  ld a,%11100111
  and (hl)
  ld (hl),a
  ld a,c
  and 3
  bit 0,a
  ld bc,vFont
  jr nz,$+5
  ld bc,FontSet
  rlca
  rlca \ rlca
  or (hl)
  ld (hl),a
  ld a,(de)
  cp 2Bh \ call z,ParseNextFullArg
  ld (FontPointer),bc
  ret
augment:
  call ParseFullArg
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMem
  push de
  call ParseNextFullArg
  push bc
  ld hl,(parsePtr)
  inc hl
  ld (parsePtr),hl
  call GetVarInfo
  jp c,Pop2Exit
  or a \ jp nz,Pop2Exit
  ld hl,(parsePtr)
  ld (parsePtr),hl
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl)
  ld (TempWord1),hl
  pop de \ pop hl
InsertData:
  push hl
  add hl,bc
  ld b,h \ ld c,l
  ld hl,(TempWord1)
  ld (hl),b \ dec hl
  ld (hl),c \ inc hl \ inc hl
  add hl,de
  pop de
;hl points to where to insert data
;de is the number of bytes to insert
  push de \ push hl
  ld a,h \ or l
  jr z,$+6
  ex de,hl
  bcall(_InsertMem)
  ld hl,(parsePtr)
  ld (parsePtr),hl
  pop hl \ pop bc
  ld d,h \ ld e,l
  jp ZeroMem
PtChange:
  call ParseFullArg       ;To get the tilemap routine correct
  call ParseNextFullArg   ;Map Data
  push bc
  call ParseNextFullArg   ;Tile Data
  push bc
  call ParseNextFullArg   ;MapWidth
  push bc
  call ParseNextFullArg   ;MapX offset
  ld (TempWord2),bc
  call ParseNextFullArg   ;MapY offset
  ld (TempWord3),bc
  call ParseNextFullArg   ;Sprite Method
  push bc
  ld bc,(BufPtr)
  ld (TempWord5),bc
  cp 2Bh
  call z,ParseNextFullArg
  ld (BufPtr),bc
  pop bc
  ld a,c
  pop hl
  pop bc
  pop de
  call TileMap1
  ld hl,(TempWord5)
  ld (BufPtr),hl
  ret
solveSet:
  ld a,(hl) \ inc hl \ ld (parsePtr),hl
  sub 30h \ ld b,a
  ld a,(hl)
  jr nz,CopyDataUp
  inc hl \ ld (parsePtr),hl
  call GetVarInfo2 \ ret c
  push af \ push hl \ push bc
  ld hl,(parsePtr)
  inc hl \ ld (parsePtr),hl
  call GetVarInfo
  jr c,$+5
  bcall(_DelVarArc)

  ld hl,(parsePtr)
  ld a,2Bh \ cp (hl)
  pop bc
  call z,ParseNextFullArg
  push bc
  ld bc,0
  ld a,(hl)
  cp 2Bh  ;,
  call z,ParseNextFullArg
  pop de \ pop hl
  add hl,bc \ push hl
  push de
  ex de,hl


  ld a,(OP1)
  and 1fh
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
  bcall(_CreateVar)
  inc de \ inc de
  pop bc \ pop hl \ pop af
  push de \ push bc
  call TSA
  pop hl \ ld (ThetaPrimeVar),hl
  pop bc \ ret
CopyDataUp:
  djnz CopyDataDown
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de \ pop hl
  ldir
  pop bc
  ret
CopyDataDown:
  djnz ErrorHandle
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de \ pop hl
  lddr
  pop bc
  ret
ErrorHandle:
  djnz CallError
  call ParseNextFullArg
  ld (ParseError),bc
  ret
CallError:
  djnz WritePort
  call ParseNextFullArg
  ld a,c
  cp 2
  jr nz,HandleError
  call ParseNextFullArg
  ld h,b \ ld l,c
  call GetGrammerText
  ld hl,13
  or a
  sbc hl,bc
  jr nc,$+5
CustomError:
  ld bc,13
  ex de,hl
  ld de,appErr1
  ldir
  xor a
  ld (de),a
  ld a,2
HandleError:
  jp GramHandl
WritePort:
  djnz ReadPort
  call ParseNextFullArg
  push bc
  ld c,0
  cp 2Bh
  call z,ParseNextFullArg
  pop de
  out (c),e
  ret
ReadPort:
  djnz +_
  ld c,0
  cp 2Bh
  call z,ParseNextFullArg
  in c,(c)
  ld b,0
  ret
_:
  djnz +_
  call ParseNextFullArg
  ld d,b
  ld e,c
  ld hl,smallEditRAM
  jr L46be
_:
  djnz EndSolveSet
  call ParseNextFullArg
  ld h,b
  ld l,c
  ld de,smallEditRAM
L46be:
  ld bc,108    ;=108, 2*54, 4*(26+1) ; could use 'call mov4 \ jp mov104's
ReadRAM:
  ldir
EndSolveSet:
  ret
ISToken:
  ld a,(hl) \ inc hl
  call VarP
  ret nc
  ld (parsePtr),de
g_ReadByte:
  ld e,(hl) \ inc (hl) \ inc hl \ ld d,(hl)
  jr nz,$+3
  inc (hl)
  ex de,hl
  ld c,(hl)
  ld b,0
  dec de
  ex de,hl
  ret
AnsToken:
  ld bc,(Ans) \ ret
#include "cmd/input.z80"
seqToken:
CopyHex:
  ex de,hl
  ld h,b \ ld l,c
_:
  call PutHexFromDE
  jr z,+_
  call PutHexFromDE
  inc hl
  jr nz,-_
  dec hl
  xor a
  rld
_:
  ld (parsePtr),de
  ld b,h \ ld c,l
  ret
PutHexFromDE:
  inc de
  ld a,(de)
  cp 3Fh
  ret z
  cp 3Ah
  jr c,$+4
  sub 7
  rld
  ret
SetData:
;[
  ld a,(hl)
  cp 16
  jr z,CopyHex      ;[(
  ld e,-1
  cp 6
  jr nz,$+5         ;[[
  inc e \ jr $+6
  dec hl
  ld (parsePtr),hl
  ld h,b \ ld l,c
_:
  push hl
  push de
  call ParseNextFullArg
  pop de
  rlc e
  jr nc,$+7
  dec hl
  ld a,(hl)
  cp 11
  inc hl
  ld a,(hl)
  pop hl
  ld (hl),c \ inc hl
  jr nz,$+4
  ld (hl),b \ inc hl
  cp 2Bh \ jr z,-_
  ld b,h
  ld c,l
  ret
VarName:
   ld e,a
   ld d,(hl)
   inc d
   call GetNextVarNum
   dec d
   ld (parsePtr),hl
   ld (OP1+1),de
   xor a \ ld (OP1+3),a    ;I don't think this is necessary
   rst rFindSym
   jp VarTokenStepIn
FuncToken:
  call ParseFullArg
  ld (IntLoc),bc
  ld bc,80h
  cp 2Bh
  call z,ParseNextFullArg
  dec bc \ inc b \ inc c
  ld (IntMax),bc
  ld (IntCount),bc
  ret
SendToken:
  ld a,(hl)
  cp $AE
  jr nz,NotSendByte
;timer,byte
;success or fail
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  jp SendByte
NotSendByte:
  call ParseFullArg
  push bc               ;Size of the var
  inc hl \ ld (parsePtr),hl
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
  pop hl
  jr nc,+_
  ld a,(OP1)
  and 1fh
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
  push hl
  bcall(_CreateVar)
  pop bc
  ld a,b
  or c
  ld h,d
  ld l,e
  inc hl
  inc hl
  ld a,$00
  call nz,SetMem
_:
  inc de \ inc de
  ld c,e \ ld b,d
  ret
PToRy:
  call ParseFullArg
  cp 2Bh
  ld (PBufType),bc
  ld bc,%01100001
  jr nz,GetRuleNum+3
  inc hl
  ld a,(hl)
  sub 2Ah
  jr nz,GetRuleNum
  ld b,h
  ld c,l
  ld h,a
  ld l,a
ConvRuleLoop:
  inc bc
  ld a,(bc)
  call EndOArg
  jr nz,$+25
  cp 2Bh
  jr z,$+17
  ld a,h \ and $F0
  jr nz,$+8
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  jr $-9
  ld (PBufRule),hl
  ret

  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  cp 'U'
  jr nz,$+4
  set 3,l
  cp 'R'
  jr nz,$+4
  set 2,l
  cp 'L'
  jr nz,$+4
  set 1,l
  cp 'D'
  jr nz,$+4
  set 0,l
  jr ConvRuleLoop
GetRuleNum:
  call ParseNextFullArg
  ld a,b
  rlca \ rlca \ rlca \ rlca
  ld (PBufRule),a
  ld a,c
  rlca \ rlca \ rlca \ rlca
  ld (PBufRule+1),a
  ret
RToPr:
  ld hl,(PBufPtr)
  inc hl \ inc hl
  ld (hl),0 \ inc hl
  ld (hl),0 \ inc hl
  ret

;===============================================================
RToPTheta:
;===============================================================
;This executes one particle cycle
;===============================================================
  ld a,(hl)
  call EndOArg
  jr z,DefaultBuffer
  call ParseFullArg
  push bc
  cp $2b
  call ParseNextFullArg_BC
  pop bc
g_ParticleCycle:
  ld (PBufPtr),bc
DefaultBuffer:
  ld hl,(PBufPtr)
  ld a,(PBufType)
  ld de,(PBufRule)
  or a
  jr nz,$+5
  ld de,%0001011000000000
  dec a
  jr nz,$+5
  ld de,%0001011010000000
  ld (TempWord1),de
;RuleSet=DE
  inc hl
  inc hl
  ld (TempWord4),hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  ld a,b
  or c
  ret z
  inc hl
;BC now is the number of particles
;HL now points to the particles
;(TempWord1) is the ruleset
  ld (TempWord2),bc
  add hl,bc
  add hl,bc
  dec hl
  ld (TempWord3),hl
  inc hl
  sbc hl,bc
  sbc hl,bc
;TempWord2 contains the number of particles left in the buffer
;TempWord3 points to the last particle
;TempWord4 points to the particle size bytes
ParticleDrawLoop:
  push bc
  push hl
  call EraseParticle
  push hl
  pop ix
  ld hl,(TempWord1)
  push af
  xor a
  ld (flags+ParticleFlag),a
  ld a,b
  or a
  jr nz,PLeft
  set 0,(iy+ParticleFlag)
  jr PUpDown
PLeft:
  sub 95
  jr c,PUpDown
  set 1,(iy+ParticleFlag)
PUpDown:
  ld a,c
  or a
  jr nz,PDown
  set 2,(iy+ParticleFlag)
  jr PPPp
PDown:
  sub 63
  jr c,PPPp
  set 3,(iy+ParticleFlag)
PPPp:
  pop bc
  ld c,0
ParticleTestLoop:
  add hl,hl
  jr nc,CheckPRight
  ld a,b
  and (ix-12)
  jr nz,CheckPRight
  ld c,8
  bit 2,(iy+ParticleFlag)
  jr z,$+6
  set 4,(iy+ParticleFlag)
CheckPRight:
  add hl,hl
  jr nc,CheckPLeft
  ld a,b
  rrca
  jr c,$+7
  and (ix)
  jr $+5
  and (ix+1)
  jr nz,CheckPLeft
  ld a,c
  or a
  jr z,$+8
  ld a,r
  bit 4,a
  jr nz,$+4
  ld c,4
  bit 1,(iy+ParticleFlag)
  jr z,$+6
  set 4,(iy+ParticleFlag)
CheckPLeft:
  add hl,hl
  jr nc,CheckPDown
  ld a,b
  rlca
  jr c,$+7
  and (ix)
  jr $+5
  and (ix-1)
  jr nz,CheckPDown
  ld a,c
  or a
  jr z,$+8
  ld a,r
  bit 4,a
  jr nz,$+4
  ld c,2
  bit 0,(iy+ParticleFlag)
  jr z,$+6
  set 4,(iy+ParticleFlag)
CheckPDown:
  add hl,hl
  jr nc,PChecked
  ld a,b
  and (ix+12)
  jr nz,PChecked
  ld a,c
  or a
  jr z,$+8
  ld a,r
  bit 4,a
  jr nz,$+4
  ld c,1
  bit 3,(iy+ParticleFlag)
  jr z,$+6
  set 4,(iy+ParticleFlag)
PChecked:
  ld a,c
  or a
  jr nz,MoveP
  ld a,h
  or l
  jp nz,ParticleTestLoop
MoveP:
  pop hl
  ld a,c
  or a
  jr z,MovedP
  ld a,b
  cpl
  and (ix)
  ld (ix),a
  bit 4,(iy+ParticleFlag)
  jr nz,RemoveParticle
  ld a,b
  rrc c
  jr nc,$+11
  or (ix+12)
  ld (ix+12),a
  inc (hl)
  jr MovedP
  rrc c
  jr nc,$+23
  rlca
  jr nc,$+10
  or (ix-1)
  ld (ix-1),a
  jr $+8
  or (ix)
  ld (ix),a
  inc hl
  dec (hl)
  jr MovedP+1
  rrc c
  jr nc,$+23
  rrca
  jr nc,$+10
  or (ix+1)
  ld (ix+1),a
  jr $+8
  or (ix)
  ld (ix),a
  inc hl
  inc (hl)
  jr MovedP+1
  or (ix-12)
  ld (ix-12),a
  dec (hl)
MovedP:
  inc hl
  pop bc
  cpi
  jp pe,ParticleDrawLoop
  ret
RemoveParticle:
;HL points to particle data
;TempWord2 contains the number of particles left in the buffer
;TempWord3 points to the last particle
;TempWord4 points to the particle size bytes
  res 4,(iy+ParticleFlag)
  ld bc,(TempWord2)
  cpi
  ex de,hl
  push af
  ld hl,(TempWord3)
  ld (TempWord2),bc
  ldd
  ldd
  ld (TempWord3),hl
  ld hl,(TempWord4)
  inc bc
  inc bc
  ld (hl),c
  inc hl
  ld (hl),b
  ex de,hl
  pop af
  pop bc
  ret po
  cpi
  jp pe,ParticleDrawLoop
  ret
;===============================================================
PBufInfoDef:
  ld hl,(PBufPtr)
PBufInfo:
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld e,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ret
NextParticle:
  sra b \ rr c \ dec bc
  ex de,hl
  sbc hl,bc \ ret z
  add hl,bc
  inc hl
  ex de,hl
  ld (TempWord1),hl
  dec hl \ ld (hl),d
  dec hl \ ld (hl),e
  ex de,hl
  add hl,hl
  add hl,de
  or 1
  ret
PartConv:
; jr $
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  ld a,c
  pop bc \ ld b,a
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg

  cp $2b

  ld a,c

  push af
  call ParseNextFullArg_BC
  pop af

  pop bc \ ld b,a
  pop hl \ ld (TempWord3),hl
  add hl,bc \ dec h \ dec l
  ld (TempWord2),bc
;HL contains the lower-left coordinates
PartConvLoop:
  push hl
  push bc
  ld (TempWord4),hl
  ld b,h \ ld c,l
  call GetPixelLoc
  jr nc,FinishPartAdd
  and (hl) \ jr z,FinishPartAdd
  call PBufInfoDef
  call NextParticle \ jr z,PConvComplete
  ld bc,(TempWord4)
  ld (hl),c \ inc hl \ ld (hl),b
FinishPartAdd:
  pop bc \ pop hl
;TempWord2 is the size of the reqion
;TempWord3 is is the upper right coordinate
  dec h \ djnz PartConvLoop
  ld hl,(TempWord3)
  ld bc,(TempWord2) \ dec c
  add hl,bc
  jr nz,PartConvLoop-6
  pop bc \ ret
PConvComplete:
  pop bc \ pop hl \ pop bc \ ret ;zuviel
FillPart:
  ret
ParseNextFullArg_BC:
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  ld (BufPtr0e),bc
  ret
PToRX:
  ld a,(hl) \ cp $AE
  jr z,PartConv
  cp 11 \ jr z,FillPart
  call PBufInfoDef
;BC=Max number of particles
;DE=Current number of particles
;HL=particle pointer
  call NextParticle
  ld de,(TempWord1)
  push de
  push hl
;HL points to where particle data gets written
  call ParseFullArg
  push bc
  call ParseNextFullArg
  ld a,c
  pop bc \ ld b,a
  pop hl \ pop de
AddParticle:
  ld (hl),c \ inc hl
  ld (hl),b
  call GetPixelLoc
  or (hl) \ ld (hl),a
  ld b,d \ ld c,e
  ret
FixToken:
  ld a,(hl)
  cp 93h
  jr nz,SetMode
  call ParseNextFullArg
  ld a,c
  ld (TextPauseTime),a
  ret
SetMode:
  ld bc,(flags+34)
  ld b,0
  call ParseFullArg
  ld a,c
  ld (flags+34),a
  ret
OSVarToken:
  ld a,(hl)
  inc hl
  ld (parsePtr),hl
  ld hl,0
  ld (OP1+2),hl
  ld (OP1+1),a
  rst rFindSym
  jr nc,$+6
  ld bc,0
  ret
  ex de,hl
  call convFloat
  ld b,d \ ld c,e
  ret
TangentToken:
  call ParseFullArg
  xor a \ ld b,a
  or c
  ret z
  push bc
  call ParseNextFullArg
  ld a,c
  pop bc
  or a \ ret z
  push af
  push bc
  ld a,(hl)
  cp 2Bh
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  ld (TempWord1),bc
  pop bc
  pop af
ShiftGraphBuf:
  ld b,4
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphDownA
  pop af
  pop bc
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphLeftA
  pop af
  pop bc
  push bc
  rrca
  push af
  ld a,c
  call c,ShiftGraphRightA
  pop af
  pop bc
  rrca
  ld a,c
  ret nc
ShiftGraphUpA:
  ld e,a
  ld l,a
  ld h,0
  ld d,h
  add hl,hl
  add hl,de
  add hl,hl
  add hl,hl
  push hl
  ld a,h
  inc a
  cpl
  and 3
  ld b,a
  ld a,l
  dec a
  cpl
  ld c,a
  ld de,(TempWord1)
  add hl,de
  ldir
  pop bc
ZeroMemF:
  xor a
SetMemF:
  ld (de),a
  ld h,d \ ld l,e
  inc de
  ldir
  ret
ShiftGraphRightA:
  rrca
  push af
  call c,ShiftRight1
  pop af
  rrca
  push af
  call c,ShiftRight2
  pop af
  rrca
  push af
  call c,ShiftRight4
  pop af
  rrca
  push af
  call c,ShiftRight8
  pop af
  rrca
  push af
  call c,ShiftRight16
  pop af
  rrca
  push af
  call c,ShiftRight32
  pop af
  rrca
  ret nc
ShiftRight64:
  ld hl,(TempWord1)
  ld a,l
  sub 9
  jr nc,$+3
  dec h
  ld l,a
  ld a,4
  jr ShiftRight8OrMore
ShiftRight32:
  ld hl,(TempWord1)
  ld a,l
  sub 5
  jr nc,$+3
  dec h
  ld l,a
  ld a,8
  jr ShiftRight8OrMore
ShiftRight16:
  ld hl,(TempWord1)
  dec hl \ dec hl \ dec hl
  ld a,10
ShiftRight8OrMore:
  inc h
  inc h
  inc h
  ld b,0
  ld c,a
  ld (TempWord3),bc
  sub 13
  cpl
  ld (TempWord2+1),a
  ld b,64
  ld de,(TempWord1)
  inc d \ inc d \ inc d
  dec de
SR8OMLoop:
;TempWord2==number of bytes to clear
;TempWord3==number of bytes to shift
;b=64
  push bc
  ld bc,(TempWord3)
  lddr
  ld bc,(TempWord2)
  xor a
  ld (de),a
  dec de
  dec hl
  djnz $-3
  pop bc
  djnz SR8OMLoop
  ret
ShiftRight8:
  ld hl,(TempWord1)
  ld d,64
  xor a
  ld b,12
  ld c,(hl)
  ld (hl),a
  inc hl
  ld a,c
  djnz $-4
  dec d
  jr nz,$-10
  ret
ShiftRight2:
  call ShiftRight1
ShiftRight1:
  ld hl,(TempWord1)
  ld c,64
  xor a
  ld b,12
  rr (hl)
  inc hl
  djnz $-3
  dec c
  jr nz,$-9
  ret
ShiftRight4:
  ld hl,(TempWord1)
  ld c,64
  xor a
  ld b,12
  rrd
  inc hl
  djnz $-3
  dec c
  jr nz,$-9
  ret
ShiftGraphLeftA:
  rrca
  push af
  call c,ShiftLeft1
  pop af
  rrca
  push af
  call c,ShiftLeft2
  pop af
  rrca
  push af
  call c,ShiftLeft4
  pop af
  rrca
  push af
  call c,ShiftLeft8
  pop af
  rrca
  push af
  call c,ShiftLeft16
  pop af
  rrca
  push af
  call c,ShiftLeft32
  pop af
  rrca
  ret nc
ShiftLeft64:
  ld hl,(TempWord1)
  ld a,8
  add a,l
  jr c,$+3
  inc hl
  ld l,a
  ld a,4
  jr ShiftLeft8OrMore
ShiftLeft32:
  ld hl,(TempWord1)
  inc hl \ inc hl
  inc hl \ inc hl
  ld a,8
  jr ShiftLeft8OrMore
ShiftLeft16:
  ld hl,(TempWord1)
  inc hl \ inc hl
  ld a,10
ShiftLeft8OrMore:
  ld b,0
  ld c,a
  ld (TempWord3),bc
  sub 13
  cpl
  ld (TempWord2+1),a
  ld b,64
  ld de,(TempWord1)
SL8OMLoop:
  push bc
  ld bc,(TempWord3)
  ldir
  ld bc,(TempWord2)
  xor a
  ld (de),a
  inc de
  inc hl
  djnz $-3
  pop bc
  djnz SL8OMLoop
  ret
ShiftLeft8:
  ld hl,(TempWord1)
  inc h \ inc h \ inc h
  dec hl
  ld d,64
  xor a
  ld b,12
  ld c,(hl)
  ld (hl),a
  dec hl
  ld a,c
  djnz $-4
  dec d
  jr nz,$-10
  ret
ShiftLeft2:
  call ShiftLeft1
ShiftLeft1:
  ld hl,(TempWord1)
  inc h
  inc h
  inc h
  dec hl
  ld c,64
  xor a
  ld b,12
  rl (hl)
  dec hl
  djnz $-3
  dec c
  jr nz,$-9
  ret
ShiftLeft4:
  ld hl,(TempWord1)
  inc h \ inc h \ inc h
  dec hl
  ld c,64
  xor a
  ld b,12
  rld
  dec hl
  djnz $-3
  dec c
  jr nz,$-9
  ret
ShiftGraphDownA:
  ld e,a
  ld l,a
  ld h,0
  ld d,h
  add hl,hl
  add hl,de
  add hl,hl
  add hl,hl
  push hl
  ld a,h
  inc a
  cpl
  and 3
  ld b,a
  ld a,l
  dec a
  cpl
  ld c,a
  ld hl,(TempWord1)
  dec hl
  add hl,bc
  ld de,(TempWord1)
  inc d \ inc d \ inc d
  dec de
  lddr
  pop bc
ZeroMemE:
  xor a
SetMemE:
  ld (de),a
  ld h,d \ ld l,e
  dec de
  lddr
  ret
PiToken:
ConvHexStr:
  xor a
  ex de,hl
  ld h,a
  ld l,a
_:
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,hl
  or l
  ld l,a
  call IsHexTok
  jr nc,-_
_:
  dec de
  ld (parsePtr),de
  ld b,h \ ld c,l
  ex de,hl
  ret
#ifdef include_ncr
#include "cmd/ncr.z80"
#endif
ForToken:
  push bc
  ld a,(hl)
  inc hl
  call VarP
  jr c,+_
  ld hl,ForBackUp
  push hl
  ld (hl),1
  inc l
  ld (hl),0
  call ParseFullArg
  jr StartForLoop-4
_:
  ld (parsePtr),de
  push hl
  call ParseNextFullArg
  pop hl
  push  hl
  ld (hl),c \ inc hl
  ld (hl),b
  call ParseNextFullArg
  ld e,c
  ld d,b
  pop hl
  pop bc
StartForLoop:
  push de              ;UpperBound
  push hl              ;varPointer
  ld hl,(parsePtr)
  push hl
  call ParserNext
  pop hl
  ld (TempWord2),hl
  ld (TempWord1),bc
  pop hl                ;points to var data
  pop de                ;upper bound
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc bc
  ld (hl),b
  dec hl
  ld (hl),c
  ex de,hl
  or a
  sbc hl,bc
  add hl,bc
  ld bc,(TempWord1)
  ret c
  push hl
  ld hl,(TempWord2)
  ld (parsePtr),hl
  pop hl
  ex de,hl
  jr StartForLoop
FullToken:
  ld a,(hl)
  ld c,1
  call EndOArg
  call nz,ParseFullArg
SetSpeed:
  in a,(20h)
  ld b,a
  bit 1,c
  jr z,$+6
  cpl
  and 1
  ld c,a

  in a,(2)
  rlca
  and c
  out (20h),a
  ld c,b
  ld b,0
  ret
ClrDrawToken:
  ld a,(hl)
  call EndOArg
  jr z,g_ClrDraw
  call ParseFullArg
  ld h,b \ ld l,c
  ld d,b \ ld e,c
  jp ZeroMem768
g_ClrDraw:
  ld de,0
  ld (textRow),de
  push bc
  ld hl,(BufPtr)
  pop de
ZeroMem768:
  ld bc,768
ZeroMem:
  ld a,b \ or c \ ld a,0
  push de
  call nz,SetMem
  pop bc
  ret
ClrHomeToken:
g_ClrHome:
  ld hl,0
  ld (CurRow),hl
  push bc
  ld b,128
  ld hl,textShadow
  ld a,' '
  call SetSmallMem
  pop bc
  ret
minToken:
maxToken:
  push af
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  pop af
g_max:
  or a
  sbc hl,bc
  add hl,bc
  bit 0,a
  jr nz,$+3
  ccf
  ret c
  ld b,h
  ld c,l
  ret
factorialToken:
  ld a,(hl)
  call IsConditional \ jr z,$+9
  ld de,0 \ push de
  jp factorialStepIn
  set invlogic,(iy+gflags)
  ret
FillToken:
  call ParseFullArg
  ld hl,(BufPtr)
  ld a,c
  ld bc,300h
  ld e,-1
FillBufOR:
  or a \ jr nz,FillBufInv
  ld a,e \ or (hl) \ ld (hl),a
  cpi
  jp pe,$-5
  ret
FillBufInv:
  dec a \ jr nz,Checker1
  ld a,e \ xor (hl) \ ld (hl),a
  cpi
  jp pe,$-5
  ret
Checker1:
  dec a \ jr nz,Checker2
  ld a,$AA
  ld c,64
  ld b,12 \ ld (hl),a \ inc hl
  djnz $-2
  cpl \ dec c
  jr nz,$-8
  ret
Checker2:
  dec a \ jr nz,LoadBytePatternOR
  ld a,55h \ jr Checker1+5
LoadBytePatternOR:
  cp 22 \ jr nc,NotArg
  push af \ push bc \ push hl
  call ParseNextFullArg
  ld d,b \ ld e,c \ pop hl \ pop bc \ pop af
NotArg:
  dec a \ jr z,FillBufOR+3
LoadBytePatternXOR:
  dec a \ jr z,FillBufInv+3
LoadBytePatternAND:
  dec a \ jr nz,LoadBytePatternErase
FillBufAND:
  ld a,e \ and (hl) \ ld (hl),a
  cpi
  jp pe,FillBufAND
  ret
LoadBytePatternErase:
  dec a \ jr nz,BufCopy
FillBufErase:
  ld a,e \ cpl \ and (hl) \ ld (hl),a
  cpi
  jp pe,FillBufErase
  ret
BufCopy:
  dec a \ jr nz,BufOR
  jp mov768
BufOR:
  dec a \ jr nz,BufAND
  ld a,(de) \ inc de
  or (hl) \ ld (hl),a
  cpi \ jp pe,BufOR+3
  ret
BufAND:
  dec a \ jr nz,BufXOR
  ld a,(de) \ inc de
  and (hl) \ ld (hl),a
  cpi \ jp pe,BufAND+3
  ret
BufXOR:
  dec a \ jr nz,BufErase
  ld a,(de) \ inc de
  xor (hl) \ ld (hl),a
  cpi \ jp pe,BufXOR+3
  ret
BufErase:
  dec a \ jr nz,BufSwap
  ld a,(de) \ inc de
  cpl \ and (hl) \ ld (hl),a
  cpi \ jp pe,BufErase+3
  ret
BufSwap:
  dec a \ jr nz,CopyDown
  ld a,(de)
  push af \ ld a,(hl) \ ld (de),a
  pop af \ ld (hl),a
  inc de
  cpi \ jp pe,BufSwap+3
  ret
CopyDown:
;If Copy Down
  cp 5 \ jr nc,CopyDownOR
  add hl,bc \ dec hl
  push hl
  ld h,d \ ld l,e
  add hl,hl \ add hl,de
  add hl,hl \ add hl,hl
  pop de \ push de \ push hl \ ex de,hl
  sbc hl,de \ ex de,hl
  ld h,b \ ld l,c \ pop bc \ sbc hl,bc
  ld b,h \ ld c,l
  pop hl
CopyDownOR:
  dec a \ jr nz,CopyDownAND
  ld a,(de)
  or (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,$-6
  ret
CopyDownAND:
  dec a \ jr nz,CopyDownXOR
  ld a,(de)
  and (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,$-6
  ret
CopyDownXOR:
  dec a \ jr nz,CopyDownErase
  ld a,(de)
  xor (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,$-6
  ret
CopyDownErase:
  dec a \ jr nz,CopyUp
  ld a,(de)
  cpl
  and (hl)
  ld (hl),a
  dec de \ cpd
  jp pe,$-7
  ret
CopyUp:
;If Copy Up
  cp 5 \ jr nc,CopyUpOr
;de is number of pixels down to copy to
;bc is 768
;hl points to the buffer
  push hl
  ld h,d \ ld l,e
  add hl,de \ add hl,de
  add hl,hl \ add hl,hl
  ld b,h \ ld c,l
  pop de \ add hl,de
;DE points to main buffer
;HL points to offset
  push hl
  ld hl,768 \ sbc hl,bc
  ld b,h \ ld c,l
  pop hl
  ex de,hl
CopyUpOR:
  dec a \ jr nz,CopyUpAND
  ld a,(de)
  or (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,$-6
  ret
CopyUpAND:
  dec a \ jr nz,CopyUpXOR
  ld a,(de)
  and (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,$-6
  ret
CopyUpXOR:
  dec a \ jr nz,CopyUpErase
  ld a,(de)
  xor (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,$-6
  ret
CopyUpErase:
#ifdef include_fire
  dec a \ jr nz,+_
#else
  dec a \ ret nz
#endif
  ld a,(de)
  cpl
  and (hl)
  ld (hl),a
  inc de \ cpi
  jp pe,$-7
  ret
_:
#ifdef include_fire
#include "cmd/fire.z80"
#endif
HorizontalToken:
  call ParseFullArg

  ld a,b \ or a \ ret nz
  ld a,c
  cp 64
  ret nc
  push bc
  ld c,1
  ld a,(hl)
  cp 2Bh
  call z,ParseNextFullArg
  ld d,c
  cp 2Bh
  push de
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  pop de
  pop hl
  push bc
  ld b,h
  ld c,l
  add hl,hl \ add hl,bc
  add hl,hl \ add hl,hl
  ld a,d
  pop bc
  add hl,bc
  ld b,12
  or a
  jr z,SetSmallMem
  dec a
  jr nz,InvertMem
  dec a
SetSmallMem:
  ld (hl),a
  inc hl
  djnz $-2
  ret
InvertMem:
  ld a,(hl)
  cpl
  ld (hl),a
  inc hl
  djnz $-4
  ret
VerticalToken:
  call ParseFullArg
  ld a,b \ or a \ ret nz
  ld a,c \ cp 96 \ ret nc
  ld a,c
  and 7
  ld b,a
  ld a,80h
  jr nz,$+5
  rrca
  djnz $-1
  srl c \ srl c \ srl c
  push af
  push bc
  ld a,(hl) \ cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  ld b,c
  push bc
  ld bc,(BufPtr)
  cp 2Bh
  call z,ParseNextFullArg
  pop af
  pop hl
  add hl,bc
  pop bc
  ld c,b
;=======================================
;     C is the mask
;     A is the method:
;        0=Off
;        1=On
;        2=Invert
;     HL is where to start
;=======================================
  ld b,64
  ld de,12
DrawVertOn:
  dec a \ jr nz,DrawVertInv
  ld a,c
  or (hl)
  ld (hl),a
  add hl,de
  djnz $-4
  ret
DrawVertInv:
  dec a \ jr nz,DrawVertOff
  ld a,c
  xor (hl)
  ld (hl),a
  add hl,de
  djnz $-4
  ret
DrawVertOff:
  ld a,c
  cpl
  ld c,a
  ld a,c
  and (hl)
  ld (hl),a
  add hl,de
  djnz $-4
  ret
ShadeToken:
  call ParseFullArg
  ld a,c
  add a,$D9
  jr nc,$+3
  xor a
  dec a
  out (16),a
  ret
StorePicToken:
  call ParseFullArg
  ld b,c
  ld c,60h
  push bc
  cp 2Bh
  ld bc,(BufPtr)
  call z,ParseNextFullArg
  pop hl
  push bc
  ld (OP1+1),hl
  xor a
  ld (OP1+3),a
  rst rFindSym
  jr c,$+5
  bcall(_DelVarArc)
  ld hl,768
  ld a,7
  bcall(_CreateVar)   ;_CreatePict only stores 756 bytes.
  inc de
  inc de
  pop hl
mov768:
;14656cc vs 16123cc
  ld bc,768
_:
  call mov12
  jp pe,-_
  ret
RecallPicToken:
  call ParseFullArg
  push bc
  cp 2Bh
  ld c,0
  call z,ParseNextFullArg
  ld b,c
  push bc
  ld bc,(BufPtr)
  cp 2Bh
  call z,ParseNextFullArg
  pop af
  ex af,af'
  ld d,b
  ld e,c
  pop bc
  push de
;de buffer to store to
;bc is pic num
;A' is the method to copy with
  ld b,c
  ld c,60h
  ld (OP1+1),bc \ rst rFindSym
  pop hl
  ret c
  push hl
  ld a,b
  ld b,0
  push af
  call GetVarInfoVarFound
  dec bc
  ld a,b
  inc bc
  sub 3
  jr c,$+5
  ld bc,768
  pop af
  ld de,saveSScreen
  push bc
  push de
  call ReadArc
  pop hl
  pop bc
  pop de
  ex af,af'
;'
  or a
  jp z,BufCopy+3
  ex de,hl
  dec a
  jp z,BufAND+3
  dec a
  jp z,BufXOR+3
  dec a
  jp z,BufOR+3
  dec a
  ret z
  dec a
  jp z,BufErase+3
  ret
RandToken:
g_Rand:
  call prng16
  ld b,h
  ld c,l
  ret
BBTokens:
  ld a,(hl)
  inc hl
  cp $64    ;the G-T token
  jr nz,+_
  ld a,(hl)
  ld bc,9340h
  cp $AE
  jr nz,$+6
  inc hl
  ld bc,9872h
  ld (parsePtr),hl
  ret
_:
  ld (parsePtr),hl
  cp $B0
  jr c,length
  cp $CB
  jr nc,length
  cp $BB
  jr c,$+3
  dec a
  sub $AC
  add a,a
  inc a
  ex de,hl
  ld l,a
  ld h,91h
  ld c,(hl)
  inc l
  ld b,(hl)
  ex de,hl
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  ld (parsePtr),de
  ld d,b
  ld e,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  set FactorialFlag,(iy+InternalFlag)
  ret
length:
  cp 2Bh \ jr nz,inString
  ld a,(hl)
  cp $AE  ;'
  jr nz,FindVarInfo
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  push bc
  ld bc,3Fh
  cp 2Bh \ call z,ParseNextFullArg
  ld a,c
  pop de
  pop bc
  pop hl
  call SearchLine
  ld (ThetaPrimeVar),hl
  ld b,d \ ld c,e
  ret
;HL is start address
;BC is the line number
;E is the NewLine byte
FindvarInfo:
  call GetVarInfo2
  ld (ThetaPrimeVar),hl
  ret nc
  ld bc,-1
  ret
inString:
  cp 15 \ jr nz,conj
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  cp 2Bh        ;If there is another argument, then it is to put a limit on how mnay bytes to compare
  ld h,b \ ld l,c
  push hl
  jr z,+_
  call nz,GetGrammerStr
  cp a
_:
  call z,ParseNextFullArg
  ld (ThetaPrimeVar),bc
  pop de
  pop hl
  push bc
  call SearchString
  pop bc
  jr c,+_
  ld h,b \ ld l,c
_:
  or a \ sbc hl,bc
  ld b,h \ ld c,l
  ret
conj:
;n = f(x) = 440*(12th root (2^(x-48))
;A=1, B=3, C=4, D=6, E=8, F=9, and G=11
;Sharp is add 1
;flat is minus 1
  cp 37 \ jr nz,subToken
  ei
  ld a,(hl)
  cp $AE
  jr nz,GrammerSound
  call ParseNextFullArg
  push bc
  inc hl \ ld a,(hl)
  cp $AE \ push af
  call ParseNextFullArg
  pop af
  jr nz,SoundData
  ld h,b \ ld l,c \ pop bc
p_FreqOut:
  xor a
__FreqOutLoop1:
  push bc
  xor 3
  ld e,a
_:
  ld a,h
  or l
  jr z,+_
  cpd
  jp pe,-_
  ld a,e
  scf
_:
  pop bc
  out (0),a
  ret nc
  jr __FreqOutLoop1
__FreqOutEnd:
SoundData:
  push bc
  call ParseNextFullArg
  pop hl \ pop de
  ld a,b \ or c \ ret z
;HL points to the data:
;DE is the time
;BC is the number of elements
SoundLoop:
  push de \ push bc
  ld c,(hl) \ inc hl
  ld b,(hl) \ push hl
  ex de,hl
  call p_FreqOut
  pop hl \ pop bc \ pop de
  cpi
  jp pe,SoundLoop
  ret
GrammerSound:
  call ParseFullArg
  push bc
  call ParseNextFullArg
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  pop bc
  add hl,bc
  add hl,hl
  push hl
  call ParseNextFullArg
  ld d,b
  ld e,c
  pop hl
  ld bc,FrequencyLUT
  add hl,bc
  ld c,(hl)
  inc hl
  ld b,(hl)
NoteLoop:
  ld a,d
  or e
  ret z
  push de
  ld hl,4096
  call p_FreqOut
  pop de
  dec de
  jp NoteLoop
subToken:
  cp 12 \ jr nz,ANOVAsubset
  call ParseFullArg
  push bc
  call ParseNextFullArg
  push bc
  ld hl,(parsePtr)
  inc hl
  ld (parsePtr),hl
  call GetVarInfo
  jp c,Pop2Exit
  or a \ jp nz,Pop2Exit
  ld hl,(parsePtr)
  ld (parsePtr),hl
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld (TempWord1),hl
  ld h,b \ ld l,c
  pop bc
  sbc hl,bc
  pop de
  ret c
  sbc hl,de
  jr nc,DelGoodSize
  ex de,hl
  add hl,de
  ld h,a \ cp l \ ret z
  ex de,hl
  ld hl,0
DelGoodSize:
  add hl,bc
  push de
  ld de,(TempWord1)
  ex de,hl
  dec hl \ ld (hl),d
  dec hl \ ld (hl),e
  inc hl \ inc hl
  add hl,bc
  pop de
  push hl
  ld a,d \ or e
  jr z,$+5
  bcall(_DelMem)
  ld hl,(parsePtr)
;  ld (parsePtr),hl   ;seems redundant, I probably messed up when I was cleaning the code.
  pop bc
  ret
ANOVAsubset:
DelvarToken:
  cp 54h \ jr nz,UnArchiveToken
  call GetVarInfo \ ret c
  bcall(_DelVarArc)
  ret
UnArchiveToken:
  cp 69h \ jr nz,ArchiveToken
  call GetVarInfo \ ret c
  or a \ ret z
  bcall(_Arc_Unarc)
  bcall(_ChkFindSym)
  ex de,hl
  ld e,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ex de,hl \ ld c,e \ ld b,d
  ld (ThetaPrimeVar),hl
  ret
ArchiveToken:
  cp 68h \ jr nz,AsmToken
  call GetVarInfo \ ret c
  or a
  ret nz
  bcall(_Arc_Unarc)
  ret
AsmToken:
  cp 6Ah \ jr nz,expr
; jr $
  push bc
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  ld hl,9D95h ;start VarRAM
  ld (TempWord1),hl
  pop hl \ ld (TempWord2),hl
  bcall(_ChkFindSym)
  ld a,b
  ld (TempWord3),a
  ex de,hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld a,(hl) \ inc hl \ cp $BB
  ret nz
NotASMHeader:
  ld a,(hl) \ inc hl \ cp $6D
  jr nz,CheckUnsquishedHex
StartASMProg:
  dec bc \ dec bc
;BC is size of the data
;HL points to the bytes to copy
;(TempWord3) is the flash page
  push hl \ push bc
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
;HL # bytes
;DE addr
  ld de,9D95h ;start VarRAM
  push de
  bcall(_InsertMem)
  pop de \ pop bc \ pop hl
  ld a,(TempWord3) \ or a
  jr nz,$+3
  add hl,bc
  push bc
  call ReadArc
  pop de
  jr CallProg-7
CheckUnsquishedHex:
  cp 6Ch \ jr nz,NotASMHeader
  jr NotASMHeader
  ld hl,(parsePtr)
  add hl,de
  ld (parsePtr),hl
;===============================================================
CallProg:
  ld bc,(TempWord2)
  push de
  ld de,AfterRet \ push de
  ld de,(TempWord1) \ push de
  ret
AfterRET:
  ld hl,(parsePtr)
  pop de
  or a
  sbc hl,de
  ld (parsePtr),hl
  ld hl,9D95h ;start VarRAM
;Delmem: HL address
;        DE # of bytes
  bcall(_DelMem)
  ret
expr:
  cp 2Ah \ jr nz,AsmPrgm
  call ParseFullArg
g_expr:
  ld hl,(parsePtr) \ push hl
  ld (parsePtr),bc
  call ParseCondition
  pop hl
  ld (parsePtr),hl
  ret
AsmPrgm:
  cp 6Ch \ jr nz,OMNom
  push bc
  ld b,h \ ld c,l
  call ConvHexTo86ECh
  ex de,hl
  ld (parsePtr),hl
  pop bc
  jp 86ECh
OMNom:
;Note from Future Zeda: "I love you, Past Zeda."
;        cp 5 \ jr nz,BBrandInt
;          dec hl \ dec hl \ dec hl
;          ld a,(hl) \ cp 4Dh \ ret nz
;          dec hl
;          ld a,(hl) \ cp 4Fh \ ret nz
;          call ParseFullArg
;          ld a,c \ and 3
;          add a,12
;          out (16),a
;          ret
BBrandInt:
  cp 10 \ jr nz,BBLCM
  call ParseFullArg
  push bc
  push bc
  call ParseNextFullArg
  ld h,b \ ld l,c
  push hl
  call prng16
  ld b,h
  ld c,l
  pop hl
  pop de
  or a \ sbc hl,de
  call HL_Times_BC
  pop hl \ add hl,de
  ld b,h \ ld c,l
  ret
BBLCM:
  cp 8
  jr nz,BBGCD
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop de
LCM_BC_DE:
  push de
  call DE_Times_BC
  pop de
  push hl
  ex de,hl
  call GCDHL_BC
  pop hl
  call HL_Div_BC
  ld b,h
  ld c,l
  ret
BBGCD:
  cp 9
  ret nz
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
;===============================================================
GCDHL_BC:
;===============================================================
;Inputs:
;     hl,bc
;Outputs:
;     a is 0
;     bc is the Greatest Common Divisor
;     de is 0
;Destroys:
;     hl
;===============================================================
  or a
  sbc hl,bc
  ret z
  add hl,bc
  jr nc,$+8
  ld a,h
  ld h,b
  ld b,a
  ld a,l
  ld l,c
  ld c,a
_:
  call HL_Div_BC
  or d \ or e \ ret z
  ld h,b \ ld l,c
  ld b,d \ ld c,e
  jr -_
CircleToken:
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld d,c
  push de
  call ParseNextFullArg
  push bc
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  push bc
  ld c,00
  cp 2Bh
  call z,ParseNextFullArg
  ld a,c
  pop bc
  ld b,a
  ld (TempWord1),bc
  ld a,(hl)
  cp 2Bh
  call ParseNextFullArg_BC
  pop bc
  pop de
  jp Circle
PauseToken:
  ld a,(hl)
  call EndOArg
  push bc
  jr nz,NotBASICPause
  ld h,9

  ld bc,1
  call g_Pause
  ld a,h
  call CheckKey
  jr z,$-10

  ld bc,1
  call g_Pause
  ld a,h
  call CheckKey
  jr nz,$-10

  pop bc
  ret
NotBASICPause:
  ld a,(hl) \ cp $CE \ jr nz,Pause
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  inc hl
  jr z,Pauseif
  jr PauseNotIf
Pause:
  call ParseFullArg
  pop de
g_Pause:
  push de
  ei
_:
  halt
  dec bc
  ld a,b
  or c
  jr nz,-_
  pop bc
  ret
PauseIf:
  call PauseIfLoop
  jr nz,PauseIf
  pop bc \ ret
PauseNotIf:
  call PauseIfLoop
  jr z,PauseNotIf
  pop bc \ ret
PauseIfLoop:
  ld (parsePtr),hl \ push hl
  call ParseCondition
  xor a \ ld h,a \ ld l,a \ sbc hl,bc
  pop hl
  ret
PxlTokens:
  sub $A0
PxlTestToken:
  push af
  ld a,(hl)
  cp $AE
  jr z,PxlTestBox
  call ParseFullArg
  push bc
  call ParseNextFullArg
  cp 2Bh
  ld a,c
  push af
  call ParseNextFullArg_BC
  pop af
  pop bc
  ld b,a
  pop de
PlotPixel:
  call GetPixelLoc
  ld bc,0
  jr c,+_
  bit pxlBoundsRes,(iy+UserFlags)
  ret z
  inc c
  ret
_:
  ld e,a
  and (hl)
  jr z,+_
  inc c
_:
  dec d
  jr nz,+_
  ld a,e \ or (hl) \ ld (hl),a \ ret
_:
  dec d
  jr z,+_
  dec d
  ret nz
  ld a,e
_:
  xor (hl) \ ld (hl),a \ ret
PxlTestBox:
prgmToken:
  ld (TempWord1),bc
  ld a,(hl) \ inc hl
  cp $10
  jr nz,+_
  ld (parsePtr),hl
  ld a,(hl)
  inc hl
_:
  push af
  call VarP
  ex (sp),hl
  push af
  push hl
  call ParseFullArg
  pop af
  jr nz,g_Call
  inc hl
  ld (qmarkVar),hl
  jr $+4
g_Call:
  or 1
  push af
  ld de,(progStart)
  ld hl,(parsePtr)
  or a
  sbc hl,de
  push hl
  ex de,hl
  sbc hl,bc
  push hl
  ld (parsePtr),bc
  ld bc,(TempWord1)
  call ParserNext
  pop hl
  pop de
  push hl
  ld hl,(progStart)
  add hl,de
  ld (parsePtr),hl
  pop de
  ld hl,(progStart)
  sbc hl,de
  ex de,hl
  pop af
  jr nz,+_
  pop af
  pop hl
  ld hl,(qmarkVar)
  ld (parsePtr),hl
  ret
_:
  pop af \ pop hl
  ret nc
  ld (hl),e \ inc hl
  ld (hl),d
  ret
DispToken:
  ld a,(hl)
  cp 11
  jr z,GrayBufOnly
  cp $AE
  jr z,BlackBufOnly
  call ParseFullArg
  ld (BufPtr),bc
  ld (GrayBufPtr),bc
  ret
GrayBufOnly:
  call ParseNextFullArg
  ld (GrayBufPtr),bc
  ret
BlackBufOnly:
  call ParseNextFullArg
  ld (BufPtr),bc
  ret
TextToken:
  ld a,(hl)
  cp 4 \ jr z,+_
  cp 3Eh \ jr z,+_
  cp 3Fh \ jr nz,NoRC
_:
  ld bc,(textRow)
  ld l,b \ ld b,0
  ld h,b
  ld (ThetaPrimeVar),hl
  ret
NoRC:
  res SlowTextFlag,(iy+InternalFlag)
  cp 10
  jr nz,+_
SlowText:
  set SlowTextFlag,(iy+InternalFlag)
  inc hl
  ld (parsePtr),hl
  ld a,(hl)
_:
  cp $AE
  jp nz,FindingTextStr
  inc hl
  ld (parsePtr),hl
  call LoadTextCoordinates
  call ParseNextFullArg
  push bc
  push de
  ld a,(hl)
  cp 2Bh
  ld c,10
  call z,ParseNextFullArg+3

  ld hl,OP2
  ld (hl),0
  ld (TempWord1),hl
  pop de
  pop hl
  bit SignedText,(iy+UserFlags)
  jr z,DrawNumber
  bit 7,h
  jr z,DrawNumber
  ld a,l \ cpl \ ld l,a
  ld a,h \ cpl \ ld h,a
  inc hl
  push de \ push hl \ push bc
  ld a,1Ah \ call PutSC
  pop bc \ pop hl \ pop de
DrawNumber:
  dec c
  ret z
  inc c
  ret z
DispNumBase32:
;Inputs:
;     C is the base (use 2 to 36)
;     DEHL is the number to display
;
  ld b,32
  xor a
_:
  add hl,hl
  rl e \ rl d
  rla
  cp c
  jr c,$+4
  inc l
  sub c
  djnz -_
  push bc
  push de
  push hl
  add a,30h
  cp 3Ah
  jr c,$+4
  add a,7
  ld hl,(TempWord1)
  dec l
  ld (TempWord1),hl
  ld (hl),a
  pop hl
  pop de
  pop bc
  ld a,h
  or l \ or d \ or e
  jr nz,DispNumBase32
  ld hl,(TempWord1)
  jp GPutS
;===============================================================
PutSM:
;===============================================================
;Inputs:
;     hl points to the string to display
;     bc is the size of the string
;===============================================================
  ld a,b \ or c \ ret z
_:
  push bc
  push hl
  ld a,(hl)
  call PutSC
  pop hl
  pop bc
  cpi
  jp pe,-_
  ret
FindingTextStr:
  call LoadTextCoordinates
  ret nz
  inc hl
  ld a,(hl)
  cp 3Ah      ;. displays a float
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld hl,single2str
  ld (next_page_call_address),hl
  ld h,b
  ld l,c
  ld bc,OP1
  call next_page_call
  ld h,b
  ld l,c
  jp GPutS
_:
  cp $AE
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld a,c
  jp PutSC
_:
  cp 11
  jr nz,+_
  ld (parsePtr),hl
  call ParseNextFullArg
  ld h,b \ ld l,c
  jp GPutS
_:
  call ParseNextFullArg
  push bc
  set 0,(iy+ParticleFlag)
  cp 2Bh
  jr nz,+_
  call ParseNextFullArg
  xor a
_:
  pop hl
  jr z,TokenTextLoop
PutTokenText:
;    HL points to the string
  res 0,(iy+ParticleFlag)
  ld bc,-1
TokenTextLoop:
  ld a,(hl)
  bit 0,(iy+ParticleFlag)
  jr nz,+_
  or a
  ret z
  cp 4
  ret z
  cp 3Fh
  ret z
  cp 2Ah
  ret z
_:
  push  hl
  push bc
  bcall(_Get_Tok_Strng)
  pop hl
  or a
  sbc hl,bc
  jr nc,+_
  add hl,bc
  ld b,h
  ld c,l
  ld l,0
_:
  pop de
  push hl
  ld a,(de)
  call Is_2_Byte
  jr nz,$+3
  inc de
  push de
  ld hl,OP3
  call PutSM
  pop hl
  pop bc
  inc bc
  cpi
  jp pe,TokenTextLoop
  ret
;===============================================================
LoadTextCoordinates:
;===============================================================
  ld a,(hl)
  cp 11
  jr nz,+_
  ld (parsePtr),hl
  ret
_:
  ld bc,(textRow)
  call ParseFullArg
  ld a,c
  ld (textRow),a
  ld bc,(textCol)
  call ParseNextFullArg
  ld a,c
  ld (textCol),a
  ld a,(hl)
  cp 2Bh
  ret
;===============================================================
PtOff:
  call ParseFullArg
  ld a,c \ and 7
  res SlowTextFlag,(iy+InternalFlag)
  bit 3,c
  jr z,$+6
  set SlowTextFlag,(iy+InternalFlag)
  push af
  call ParseNextFullArg
  bit SlowTextFlag,(iy+InternalFlag)
  jr z,$+8
  call ConvHexTo86ECh
  ld bc,86ECh
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld d,c
  push de
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  cp 2Bh
  ld c,8
  call z,ParseNextFullArg
  ld l,1
  ld h,c
  pop bc
  ld a,c \ cp 64 \ jp nc,Pop2Exit
  add a,h \ dec a \ sub 64
  jr c,HeightIsFinePtOff
  ld d,a \ ld a,h \ sub d \ ld h,a \ dec h
HeightIsFinePtOff:
  pop de
  ld a,b
  sub 97 \ jr nc,BadSprite
  ld a,l \ add a,a \ rlca \ rla ;hehe
  add a,b \ sub 97
  jr nc,BadSprite
  pop af
  push hl
  push af
  push de
  push bc
  ld hl,(parsePtr)
  ld a,(hl)
  cp $2b
  call ParseNextFullArg_BC
  pop bc
  pop de
  pop af
  pop hl
  ;carry flag is reset
  ;jr DrawPixelCoordSprite
  .db $DA   ;start of jp c,**, saves 1 byte, 2cc
BadSprite:
  pop af
  ret
;===============================================================
DrawPixelCoordSprite:
;===============================================================
;Inputs:
;     A is the method:
;        0=Overwrite
;        1=AND
;        2=XOR
;        3=OR
;        4=DataSwap.......Does nothing
;        5=Erase
;     B is the X-coordinate
;     C is the Y-Coordinate
;     DE points to the sprite
;     H is the height
;     L is the width     ;not added yet
;===============================================================

  ld ix,(BufPtr0e)
  di
  ex af,af'
  push hl
  ld a,b
  ld b,0
  ld h,b \ ld l,c
  add hl,hl \ add hl,bc
  add hl,hl \ add hl,hl
  push hl
  ld c,a
  srl c \ srl c \ srl c
  ld b,0
  add ix,bc
  pop bc
  add ix,bc
  push ix
  and 7
  ld (TempWord1),a
  exx
  pop hl
  ld bc,11
  exx
  pop bc
  ex af,af'
;===============================================================
;HL'=location to draw to
;B=height
;C is not needed
;A=method
;DE=sprite location

  or a
  jr nz,DrawSpriteAND-3
DrawSpriteOverwrite:
  exx
  ld de,$FF00
  call ShiftDE
  ld (TempWord3),de
  exx
DrawSpriteOverwriteLoop:
  ld a,(de)
  inc de
  exx
  ld d,0 \ ld e,a
  call ShiftDE
  push de
  ld de,(TempWord3)
  ld a,(hl)
  and e
  pop de
  or e \ ld (hl),a
  inc hl

  push de
  ld de,(TempWord3)
  ld a,(hl)
  and d
  pop de

  or d \ ld (hl),a
  add hl,bc
  exx
  djnz DrawSpriteOverWriteLoop
  ret

  dec a
  jr nz,DrawSpriteXOR-3
DrawSpriteAND:
  ld a,(de)
  inc de
  exx
  ld d,255 \ ld e,a
  call ShiftDE
  ld a,e
  and (hl) \ ld (hl),a
  inc hl
  ld a,d
  and (hl) \ ld (hl),a
  add hl,bc
  exx
  djnz DrawSpriteAND
  ret
  dec a
  jr nz,DrawSpriteOR-3
DrawSpriteXOR:
  ld a,(de)
  inc de
  exx
  ld d,0 \ ld e,a
  call ShiftDE
  ld a,e
  xor (hl) \ ld (hl),a
  inc hl
  ld a,d
  xor (hl) \ ld (hl),a
  add hl,bc
  exx
  djnz DrawSpriteXOR
  ret

  dec a
  jr nz,DrawSpriteSwap-3
DrawSpriteOR:
  ld a,(de)
  inc de
  exx
  ld d,0 \ ld e,a
  call ShiftDE
  ld a,e
  or (hl) \ ld (hl),a
  inc hl
  ld a,d
  or (hl) \ ld (hl),a
  add hl,bc
  exx
  djnz DrawSpriteOR
  ret
  dec a
  jr nz,DrawSpriteErase
DrawSpriteSwap:
  ret
DrawSpriteErase:
  ld a,(de)
  cpl
  inc de
  exx
  ld d,255
  ld e,a
  call ShiftDE
  ld a,e
  and (hl)
  ld (hl),a
  inc hl
  ld a,d
  and (hl)
  ld (hl),a
  add hl,bc
  exx
  djnz DrawSpriteErase
  ret
ShiftDE:
  ld a,(TempWord1)
  or a
  ret z
  ld b,a
_:
  rr e
  rr d
  jr nc,$+4
  set 7,e
  djnz -_
  ret
LineToken:
  ld a,(hl)
  cp $ae
  jp nz,L5a8f
  call ParseNextFullArg_Inc
  push bc
  call ParseNextFullArg
  pop de
  ld b,e
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop de
  ld b,e
  push bc
  cp $2b
  ld c,1
  call z,ParseNextFullArg
  cp $2b
  ld a,c
  push af
  call ParseNextFullArg_BC
  cp $2b
  jr nz,L5971
  inc hl
  ld a,(hl)
  cp $ae
  jr nz,+_
  call ParseNextFullArg_Inc
  push bc
  jr L596f
_:
  ld hl,$80ff
  push hl
_:
  push hl
  call ParseNextFullArg
  pop hl
  ld (hl),c
  dec l
  jp p,+_
  cp $2b
  jr z,-_
_:
  ld (hl),$ff
L596f:
  pop ix
L5971:
  pop af
  pop de
  pop hl
  ld c,a
  ld a,d
  sub h
  ld d,a
  ld a,e
  sub l
  ld e,a
  ld a,c
DrawLine:
  di
  res FactorialFlag,(iy+InternalFlag)
  res Mod2nd,(iy+InternalFlag)
  bit 2,a
  jr z,+_
  set FactorialFlag,(iy+InternalFlag)
_:
  bit 3,a
  jr z,+_
  set Mod2nd,(iy+InternalFlag)
_:
  and $f3
  ld bc,$A62F
  dec a
  jr nz,+_
  ld bc,$00B6
_:
  dec a
  jr nz,+_
  ld bc,$00AE
_:
  ld ($8101),bc
  ld a,$ff
  ld ($811a),a
  res grayMode,(iy+InternalFlag)
  ld a,(ix)
  bit Mod2nd,(iy+InternalFlag)
  jr nz,+_
  inc a
_:
  ld ($8109),a
  or a
  call z,L7158
  ld c,0
  ld a,d
  bit 7,a
  jr z,+_
  neg
  set 6,c
  ld d,a
_:
  ld a,e
  bit 7,a
  jr z,+_
  neg
  set 7,c
  ld e,a
_:
  ld b,a
  ex af,af'
  ld a,c
  exx
  rla
  ld de,12
  ld bc,1
  jr nc,+_
  ld de,-12
_:
  rla
  jr nc,+_
  dec bc
  dec bc
_:
  exx
  ld a,h
  push hl
  push bc
  ld h,00
  ld b,h
  ld c,l
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  ld c,a
  sra c
  sra c
  sra c
  jp p,+_
  dec b
_:
  add hl,bc
  ld bc,(BufPtr0e)
  add hl,bc
  and $07
  ld b,a
  ld a,$80
  jr z,+_
  rrca
  djnz $-1
_:
  push hl
  exx
  pop hl
  exx
  ex af,af'
  pop bc
  pop hl
  sla e
  jr nz,L5a2b
  ld b,d
_:
  call L5a6f
  call L5a5d
  djnz -_
  ret

L5a2b:
 sla d
L5a2d:
 call L5a6f
 sub d
 jr c,L5a39
 call L5a4b
 djnz L5a2d
 ret

L5a39:
 call L5a5d
 add a,e
 jr c,L5a45
 call L5a6f
 jp L5a39
L5a45:
 call L5a4b
 djnz L5a2d
 ret

L5a4b:
 bit Mod2nd,(iy+InternalFlag)
 call nz,$8106
 exx
 add hl,de
 exx
 inc l
 bit 7,c
 ret z
 dec l
 dec l
 ret

L5a5d:
 ex af,af'
 rrca
 inc h
 bit 6,c
 jr z,+_
 dec h
 dec h
 rlca
 rlca
_:
  jr nc,+_
  exx
  add hl,bc
  exx
_:
  ex af,af'
  ret

L5a6f:
  bit FactorialFlag,(iy+InternalFlag)
  call nz,$8106
  bit grayMode,(iy+InternalFlag)
  ret nz
  push af
  ld a,l
  cp $40
  jr nc,+_
  ld a,h
  cp $60
  jr nc,+_
  ex af,af'
  exx
  call $8100
  exx
  ex af,af'
_:
  pop af
  ret

L5a8f:
  call ParseFullArg
  push bc
  call ParseNextFullArg
  push bc
  call ParseNextFullArg
  pop hl
  pop de
  ld h,c
  push de
  push hl
  call ParseNextFullArg
  pop hl
  pop de
  ld d,c
  push de
  push hl
  call ParseNextFullArg
  cp $2b
  ld a,c
  push af
  call ParseNextFullArg_BC
  pop af
  pop bc
  pop de
  jp DrawRectToGraph

LeftParantheses:
;Read a byte
  call ParseFullArg
  ld h,b
  ld l,c
  ld c,(hl)
  ld b,0
  ret
LeftBracket:
;Read a word (little endian)
  call ParseFullArg
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  ret
iPart:
;Write a word (little endian)
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  ld b,d
  ld c,e
  ret

int:
;Write byte
  ld a,(hl)
  cp $3A
  jr z,intf
  cp $AE      ;checks for '
  push af
  call ParseFullArg
  push bc
  call ParseNextFullArg
  pop hl
  pop af
  jr nz,+_ ;Write a byte
  ld a,(bc)
  ld e,(hl)
  ld (hl),a
  ld a,e
  ld (bc),a
  ret
_:
  ld e,(hl)
  ld (hl),c
  ld c,e
  ld b,$00
  ret
intf:
  call ParseNextFullArg
  ld hl,singleTo_int16
  ld (next_page_call_address),hl
  ld h,b
  ld l,c
  call next_page_call
  ld b,h
  ld c,l
  ret
GetToken:
  ld a,(hl)
  cp $AE
  jp z,GetByte
NotGetByte:
  call GetVarName
  ex de,hl
  ld de,OP1
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
VarTokenStepIn:
  jr nc,+_
  ld bc,0
  ret
_:
  inc de
  inc de
  ld c,a
  ld (ThetaPrimeVar),bc
  ld b,d
  ld c,e
  ret
RepeatToken:
  push hl
  ex de,hl
  pop hl
  call EndOfLine
  ld (parsePtr),hl
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  jr nz,NotRepeatLoop
RepeatLoop:
  call RepeatLooper
  jr z,RepeatLoop
ExitRepeat:
  ld (parsePtr),hl
  ret
NotRepeatLoop:
  call RepeatLooper
  jr nz,NotRepeatLoop
  jr ExitRepeat
RepeatLooper:
  push de
  call ParserNext
  ld hl,(parsePtr)
  pop de
  push de
  push hl
  ld (parsePtr),de
  push bc
  call ParseCondition
  ld a,b \ or c
Pop3Exit:
  pop bc
Pop2Exit:
  pop hl
Pop1Exit:
  pop de
  ret
WhileToken:
  bit invlogic,(iy+gflags)
  res invlogic,(iy+gflags)
  jr nz,NotWhileLoop
WhileLoop:
  push hl
  ld (parsePtr),hl
  call ParseCondition
  ld a,b
  or c
  jr z,EndWhileLoop
  call ParserNext
  pop hl
  jr WhileLoop
NotWhileLoop:
  push hl
  ld (parsePtr),hl
  call ParseCondition
  ld a,b
  or c
  jr nz,EndWhileLoop
  call ParserNext
  pop hl
  jr NotWhileLoop
EndWhileLoop:
  pop de
  call FindEndToken
  ld (parsePtr),hl
  ret
EndToken:
  pop de
  ret
ErrorJump:
  bit errorChecking,(iy+InternalFlag)
  ret nz
  push de
  push hl
  push bc
  ld hl,(parsePtr)
  ld (ErrorLoc),hl
  set errorChecking,(iy+InternalFlag)
  ld hl,(parseError)
  ld a,h
  or l
  ld a,(cxErrorEP)
  call z,GramHandl
  jr z,L5c05
  ld c,a
  ld b,0
  ld de,(parsePtr)
  ld (qmarkVar),de
  ld (parsePtr),hl
  ld hl,(ThetaPrimeVar)
  push hl
  ld hl,(Ans)
  ld (Ans),bc
  push hl
  call ParserNext
  ld a,(hl)
  ld hl,(qmarkVar)
  ld (parsePtr),hl
  cp $11
  jr nz,L5bfd
  pop hl
  pop hl
  pop hl
  jr L5c06
L5bfd:
  pop hl
  ld (Ans),hl
  pop hl
  ld (ThetaPrimeVar),hl
L5c05:
  pop bc
L5c06:
  pop hl
  pop de
  res errorChecking,(iy+InternalFlag)
  ret
PtOn:
  call ParseFullArg
  ld a,c \ and 7
  res SlowTextFlag,(iy+InternalFlag)
  bit 3,c
  jr z,$+6
  set SlowTextFlag,(iy+InternalFlag)
  push af
  cp 7 \ jr nz,$+9
  ld hl,flags+33
  ld a,16
  xor (hl)
  ld (hl),a
  call ParseNextFullArg
  bit SlowTextFlag,(iy+InternalFlag)
  jr z,$+8
  call ConvHexTo86ECh
  ld bc,86ECh
  push bc
  call ParseNextFullArg
  ld (TempWord2),bc
  ld b,0
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  push hl
  call ParseNextFullArg
  pop hl
  add hl,bc
  push hl
  cp 2Bh
  ld c,1
  call z,ParseNextFullArg
  ld b,c
  push bc
  cp 2Bh
  ld c,$08
  call z,ParseNextFullArg
  pop af
  ld b,a
  ld a,(TempWord2)
  add a,c \ dec a \ sub 64
  jr c,HeightIsFinePtOn
  ld d,a \ ld a,c \ sub d \ ld c,a \ dec c
HeightIsFinePtOn:
  push bc
  ld bc,(BufPtr)
  ld hl,(parsePtr)
  ld a,(hl)
  cp 2Bh
  call z,ParseNextFullArg
  ld d,b \ ld e,c
  pop bc
  pop hl
  add hl,de
  pop de
  ld a,(TempWord2) \ inc a \ sub 64 \ jp nc,BadSprite
  pop af
;===========================================================
DrawSpriteXxY:
;===========================================================
;Inputs:
;     A is the method:
;        0=Overwrite
;        1=AND
;        2=XOR
;        3=OR
;        4=Swap
;        5=Erase
;        6=Mask
;        7=Gray
;     B is the width (in bytes)
;     C is the height (in pixels)
;     DE points to the sprite data
;     HL points to the output location
;Outputs:
;     HL is A*12 larger (next sprite down?)
;     DE points to the next byte after the sprite data
;     A is 0
;     B is not changed
;     C is 12-B
;===========================================================
  push af
  ld a,c
  di
  ex af,af'
  ld a,12
  sub b
  ld c,a
  pop af
OverwriteXxY:
  or a
  jr nz,ANDXxY
  ex af,af'
  ex de,hl
  push bc
  ldi
  inc bc
  djnz $-3
  ex de,hl
  add hl,bc
  pop bc
  dec a
  jr nz,$-11
  ret
ANDXxY:
  dec a
  jr nz,XORXxY
  ex af,af'
  push bc
  push af
  ld a,(de)
  and (hl)
  ld (hl),a
  inc de
  inc hl
  djnz $-5
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-13
  ret
XORXxY:
  dec a
  jr nz,ORXxY
  ex af,af'
  push bc
  push af
  ld a,(de)
  xor (hl)
  ld (hl),a
  inc de
  inc hl
  djnz $-5
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-13
  ret
ORXxY:
  dec a
  jr nz,SwapXxY
  ex af,af'
  push bc
  push af
  ld a,(de)
  or (hl)
  ld (hl),a
  inc de
  inc hl
  djnz $-5
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-13
  ret
SwapXxY:
  dec a
  jr nz,EraseXxY
  ex af,af'
  ld c,12
  push bc
  push af
  ld a,(de)
  ldi
  dec hl
  ld (hl),a
  inc hl
  djnz $-6
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-14
  ret
EraseXxY:
  dec a
  jr nz,MaskXxY
  ex af,af'
  push bc
  push af
_:
  ld a,(de)
  cpl
  and (hl)
  ld (hl),a
  inc de
  inc hl
  djnz -_
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-14
  ret
MaskXxY:
  dec a
  jr nz,GrayXxY
  ex af,af'
  push bc
  push af
  ex de,hl
  ld a,(de)
  and (hl)
  inc hl
  or (hl)
  ld (de),a
  inc de
  inc hl
  djnz $-7
  ex de,hl
  add hl,bc
  pop af
  pop bc
  dec a
  jr nz,$-17
  ret
GrayXxY:
  bit grayFlag,(iy+InternalFlag)
  ld a,55h
  jr z,$+3
  rrca
  ex af,af'
  push bc
  push af
  ex af,af'
  ld (hl),a
  ex de,hl
  and (hl)
  inc hl
  or (hl)
  inc hl
  ex de,hl
  push af
  ld a,(hl)
  ex af,af'
  pop af
  ld (hl),a
  inc hl
  djnz $-14
  add hl,bc
  ex af,af'
  rlca
  ex af,af'
  pop af
  pop bc
  dec a
  jr nz,$-25
  ret
;'
;===========================================================
QuoteToken:
  push hl
  call GetGrammerStr
  ld (parsePtr),hl
  ld (ThetaPrimeVar),bc
  pop bc
  ret
GetKeyToken:
  ld a,(hl)
  cp 16
  jr nz,GetKey
  call ParseNextFullArg+3
  ld a,c
CheckKey:
;46 bytes:
;Input:
;     A is the key to test for
;Output:
;     BC is 1 if the key is pressed, 0 if it is not
;     z if the key is pressed, nz if not
  cp 41 ;on-key
  jr nz,$+7
  call CheckStatus
  jr +_
  dec a \ and 63
  ld b,a
  and 7
  rr b \ rr b \ rr b
  inc b \ inc a
  ld c,a
  ld a,7Fh
  rlca
  djnz $-1
  out (1),a
  ld b,c
  ld a,7Fh
  rlca
  djnz $-1
  ld c,a
  in a,(1)
  cp c
_:
  ld c,b
  ret nz
  ld c,1
  ret
GetKeyDebounce:
  ei
  halt
  call GetKey
  ld hl,k_save
  cp (hl)
  jr nz,newkeypress
;if the keys match, decrement k_count
  inc hl
  dec (hl)
  jr z,+_
  xor a
  ret
_:
  inc hl
  ld a,(hl)
  sub K_DELAY_ACCEL+1
  jr nc,$+3
  xor a
  inc a
  ld (hl),a
  dec hl
  ld (hl),a
  dec hl
  ld a,(hl)
  ret
newkeypress:
  ld (hl),a
  inc hl
  ld (hl),K_DELAY_DEFAULT
  inc hl
  ld (hl),K_DELAY_DEFAULT
  ret
;===============================================================
GetKey:
;===============================================================
;Outputs:
;     a is a value from 0 to 56 that is the keypress
;    bc is also the key press
;     d has a bit reset, the rest are set (this is the last key group tested)
;     e is a with a mask of %11111000
;    hl is not modified
;===============================================================
  di
  ld de,$FE00
  ld a,d
  out (1),a
  push af \ pop af
  in a,(1)
  ld b,e
  xor $FF \ jr z,+_
  ld d,a
  ld c,16 \ cp 15 \ ret z
  ld c,5
  ld a,3 \ and d \ cp 3 \ ret z \ inc c
  ld a,5 \ and d \ cp 5 \ ret z \ inc c
  ld a,10 \ and d \ cp 10 \ ret z \ inc c
  ld a,12 \ and d \ cp 12 \ ret z
  ld a,d
  cpl
  ld c,e
  jp key_add
_:
  ld c,a
_:
  rlc d
  ld a,d
  out (1),a
  inc e
  sub 7Fh
  jp z,CheckOnPress
  in a,(1)
  inc a
  jr z,-_
  dec a
key_add:
  inc c
  rra
  jr c,$-2
  ld a,e
  rlca \ rlca \ rlca
  add a,c
  ld c,a
  ret
CheckOnPress:
  call CheckStatus
  ret nz
  ld c,41
  ret
ElseToken:
;Check for an If token, maybe?
  push bc
  call FindEndToken
  call EndOfLine
  ld (parsePtr),hl
  pop bc
  ret
IfToken:
  push bc
  call ParseCondition
  ld a,b
  or c
  jr z,$+3
  scf
  pop bc
  ld hl,flags+gflags
  bit invlogic,(hl)
  jr z,+_
  res invlogic,(hl)
  ret nc
_:
  ret c
  ld hl,(parsePtr)
  inc hl
  ld a,(hl)
  push bc
  cp $CF    ;Then token
  call z,FindElseEnd
  cp $D0  ;Check if it was an Else token
  jr z,+_
  call EndOfLine
  ld (parsePtr),hl
  pop bc
  ret
_:
  ld (parsePtr),hl
  pop bc
  jp ParserNext
VarToken:
  call VarP
  ld (parsePtr),de
  ld c,(hl)
  inc hl
  ld b,(hl)
  ex de,hl
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  ld (parsePtr),de
  ld e,c
  ld d,b
  ld c,(hl)
  inc hl
  ld b,(hl)
  set FactorialFlag,(iy+InternalFlag)
  ret
ParseFullArg:
  bit FactorialFlag,(iy+InternalFlag)
  jr nz,$+5
  ld de,0
  res FactorialFlag,(iy+InternalFlag)
  ld hl,(parsePtr)
  ld a,(hl)
  call EndOArg
  ret z
  cp 29h
  ret z
  call ParseArg
  jr ParseFullArg
ParseNextFullArg:
  ld hl,(parsePtr)
ParseNextFullArg_Inc:
  inc hl
ParseNextFullArg_HL:
  ld (parsePtr),hl
  jr ParseFullArg
ParseCondition:
  call ParseArg
  ld hl,(parsePtr)
  ld a,3Fh
  cp (hl)
  ret z
  jr ParseCondition
GetNextVarNum:
  inc hl
  ld a,(hl)
  cp $AE
  jr nz,+_
  set Mod2nd,(iy+InternalFlag)
  ret
_:
  sub 3Ah
  ret nc
  add a,10
  ret nc
  ld a,d
  add a,a
  add a,a
  add a,d
  add a,a
  ld d,a
  ld a,(hl)
  and 15
  add a,d
  ld d,a
  jr GetNextVarNum
StoString:
  ld e,a
  ld d,(hl)
  inc d
  call GetNextVarNum
  dec d
  ld (parsePtr),hl
  ld h,b
  ld l,c
  push bc   ;Data in Grammer prg
  push de   ;D= Str Nr; E=AA
  call GetGrammerStr
  pop hl
  bit Mod2nd,(iy+InternalFlag)
  jr z,$+3
  inc bc
  push bc
  ld b,h
  ld c,l
  ld (OP1+1),hl
  xor a
  ld (OP1+3),a
  ld (OP1+1),bc \ rst rFindSym
  jr c,$+5
;HL = pointer to the variable's Symbol Table entry
;DE = pointer to the variable's data structure
;B  = 0 for Ram, or Flashpage
;OP1=.db StrngObj,tVarStrng,tStr1,0,0; not all ntig
  bcall(_DelVarArc)
  pop hl  ;length
  push hl
  bcall(_CreateStrng)
  inc de
  inc de
  pop bc
  pop hl
  ldir
  bit Mod2nd,(iy+InternalFlag)
  ret z
  res Mod2nd,(iy+InternalFlag)
  dec de
  ld a,3Fh
  ld (de),a
  ret
StoDisp:
  ld (parsePtr),hl
  ld a,c
  ld b,0
  ld d,b
  ld e,b
  ld h,b
  ld l,b
  sub 6
  jr nc,+_
  ld a,c
  inc b
_:
  ld c,1
  or a
  jr nz,+_
  dec hl
  dec c
_:
  dec a
  jr nz,+_
  dec c
  ld hl,%1010101010101010
_:
  dec a
  jr nz,+_
  ld hl,%1001001001001001
_:
  dec a
  jr nz,+_
  ld hl,%1000100010001000
_:
  dec a
  jr nz,+_
  ld hl,%1000001000001000
_:
  dec a
  jr nz,+_
  ld hl,%1000000000001000
_:
  dec b
  jr nz,+_
  scf
  ex de,hl
  sbc hl,de
_:
  ld (GrayMask),hl
  ld hl,GrayRotate
  ld a,(hl)
  and $FC
  or c
  ld (hl),a
  ret
StoToken:
  ld a,(hl)
  inc hl
  cp $AA \ jp z,StoString
  cp $DE \ jr z,StoDisp
  cp $01 \ jr z,StoModule
  cp $3A \ jr z,StoFloat
  cp $2C \ jr nz,NotOSVar
  push bc
  ld a,(hl)
  ld (OP1+1),a
  inc hl
  ld (parsePtr),hl
  ld hl,0
  ld (OP1+2),hl
  ld h,b \ ld l,c
  bcall(_SetXXXXOP2)
  rst rFindSym
  jr nc,$+5
  bcall(_CreateReal)
  ld a,b
  or a
  jr nz,+_
  ld hl,OP2
  call mov9
_:
  pop bc
  ret
NotAVar:
  ld (parsePtr),hl
  ret
StoFloat:
  ld a,(hl)
  call VarP
  jr nc,NotAVar
  ld (parsePtr),de
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld h,b
  ld l,c
  jp mov4_page0
NotOSVar:
  call VarP
  jr nc,NotAVar
  push hl
  ld a,(de)
  ex de,hl
  inc hl
  call VarP
  jr c,+_
  dec hl
  ex de,hl \ pop hl
_:
  ld (hl),c
  inc hl
  ld (hl),b
  ld (parsePtr),de
  ret nc
  pop hl
  ld de,(ThetaPrimeVar)
  ld (hl),e
  inc hl
  ld (hl),d
  ret
StoModule:
  inc hl
  ld (parsePtr),hl
  ld hl,module_count
  ld a,(hl)
  cp 5
  jp nc,ErrPkgNotFound
  inc (hl)
  adc a,a
  add a,l
  ld l,a
  ld (hl),c
  inc hl
  ld (hl),b
  ret
Return:
  call EndOfLine
  ld c,l
  ld b,h
  ret
LblToken:
  push hl
  call ParseFullArg
  pop hl
  push bc
  call GetGrammerStr
  pop hl
  ld de,OP2
  push de
  ld a,3Ah
  ld (de),a
  inc de
  push bc
  ldir
  dec de
  ld a,3Fh
  ld (de),a
  ld hl,(parsePtr)
  ld a,(hl)
  cp 2Bh
  jr nz,+_
  inc hl
  ld (parsePtr),hl
  call GetVarInfo2
  jr nc,+_+3
_:
  ld hl,(progStart)
  ld a,3Fh
  pop bc
  inc bc
  pop de
  call SearchString
  ld b,h
  ld c,l
  ret
GotoToken:
  push bc
  call ParseFullArg
  ld (parsePtr),bc
  pop bc
  ret
DispGraph:
  ld a,(hl)
  ld hl,(BufPtr)
  call EndOArg
  jr z,$+7
  call ParseFullArg
  ld h,b
  ld l,c
  jp GraphToLCD+3
Number:
  jp ConvRStr
Math:
Sqrt:
  ld a,(hl)
  cp 3Ah
  jr z,+_
  inc hl
  cp $AE
  push af
  jr nz,$+5
  ld (parsePtr),hl
  call ParseFullArg
  ld h,b
  ld l,c
  call sqrtHL_page0
  ld (ThetaPrimeVar),de
  ld c,l
  ld b,h
  pop af
  ret nz
  ;if HL-DE<0, increment BC
  or a
  sbc hl,de
  ret nc
  inc bc
  ret
_:
  ld hl,sqrtSingle
  jr float_stepin_1
sinefloat:
  pop af
  ld hl,sinSingle
  jr float_stepin_1
_:
  ld hl,cosSingle
float_stepin_1:
  push hl     ;the call to make
  call ParseNextFullArg
  push bc     ;the second argument
  call floatstackpush
  ld b,h
  ld c,l
  pop de
  pop hl
  ld (next_page_call_address),hl
  ex de,hl
  jp next_page_call
Cos:
  ld a,(hl)
  cp 3Ah
  jr z,-_
  ld a,64
  or a
  .db 38h
Sin:
  xor a
  push af
  ld a,(hl)
  cp 3Ah
  jr z,sinefloat
  call ParseFullArg
  pop af
  add a,c
  ld d,a
Sine:
  bit 6,a
  jr z,+_
  cpl
  xor 80h
_:
  and 63
  ld c,a
  ld hl,sinTable
  ld b,0
  add hl,bc
  ld c,(hl)
  rlc d
  ret nc
  xor a
  sub c
  ld c,a
  sbc a,a
  sub b
  ld b,a
  ret
_:
  ld hl,absSingle
  jp float_stepin_1
absToken:
  ld a,(hl)
  cp 3Ah
  jr z,-_
  call ParseFullArg
  bit 7,b
  ret z
  jr negateBC
Negative:
  ld a,(hl)
  cp 3Ah
  jr z,+_
  call ParseFullArg
negateBC:
  xor a \ sub c \ ld c,a
  sbc a,a \ sub b \ ld b,a
  ret
_:
  ld hl,negSingle
  jp float_stepin_1
Add:
  push bc
  ld a,(hl)
  cp 3Ah
  jr z,+_
  call ParseFullArg
  pop hl
  xor a
  add hl,bc
  ld b,h
  ld c,l
  ld h,a
  adc a,a
  ld l,a
  ld (ThetaPrimeVar),hl
  ret
_:
  ld hl,addSingle
  jp float_stepin
SubtractToken:
  push bc
  ld a,(hl)
  cp 3Ah
  jr z,+_
  call ParseFullArg
  pop hl
  xor a
  sbc hl,bc
  ld b,h
  ld c,l
  ld h,a
  ld l,a
  ld (ThetaPrimeVar),hl
  ret
_:
  ld hl,subSingle
  jp float_stepin
Cubed:
  ld d,b
  ld e,c
  call DE_Times_BC
  ex de,hl
  jr mul_stepin
Squared:
  ld d,b
  ld e,c
  jr mul_stepin
Multiply:
  push bc
  ld a,(hl)
  cp 3Ah
  jr z,+_
  call ParseFullArg
  pop de
mul_stepin:
  call DE_Times_BC
  ld b,h
  ld c,l
  ld (ThetaPrimeVar),de
  ret
_:
  ld hl,mulSingle
float_stepin:
  push hl
  call ParseNextFullArg
  push bc
  call floatstackpush
  ld b,h
  ld c,l
  pop de
  pop hl
  ld (next_page_call_address),hl
  pop hl
  jp next_page_call
floatstackpush:
  ld hl,(floatstack_ptr)
  ld bc,4
  add hl,bc
  ld (floatstack_ptr),hl
  ld a,l \ cp floatstack_top&255
  ret nz
#if (floatstack_top>>8)!=(floatstack_bottom>>8)
  ld a,h \ cp floatstack_top>>8
  ret nz
#endif
  ld hl,floatstack_bottom
  ld (floatstack_ptr),hl
  ret
Comment:
SkipLine:
  call EndOfLine
  jp ParseArg2
  ld a,(hl)
  cp 93h \ jp z,SlowText
  cp 83h
  jr z,SkipLine
  cp 29h
  jr nz,Divide
  push bc
  call ParseNextFullArg
  pop hl
;1366cc+6cc for every 0 bit in the result (up to +90cc
;+48cc unless HL and BC are both positive
;min: 1366cc
;max: 1504cc
;avg: 1447cc
  ld a,h
  xor b
  push af
  xor b
  jp p,+_
  xor a
  sub l
  ld l,a
  sbc a,a
  sub h
  ld h,a
_:
  xor b
  jp p,+_
  xor a
  sub c
  ld c,a
  sbc a,a
  sub b
  ld b,a
_:
  call HL_Div_BC
  pop af
  jp p,+_
  xor a
  sub l
  ld l,a
  sbc a,a
  sub h
  ld h,a
_:
  ld b,h
  ld c,l
  ld (ThetaPrimeVar),de
  ret
Divide:
  push bc
  ld a,(hl)
  cp 3Ah
  jr z,+_
  call ParseFullArg
  pop hl
  call HL_Div_BC
  ld b,h
  ld c,l
  ld (ThetaPrimeVar),de
  ret
_:
  ld hl,divSingle
  jp float_stepin
Logic:
Equals:
  ld a,(hl)
  cp $3A
  jr z,feq
  push bc
factorialStepIn:
  call ParseFullArg
  pop hl
  xor a
  sbc hl,bc
  ld b,a
  ld c,a
  ret nz
  inc c
  ret
feq:
  call fcmp
  ld bc,0
  ret nz
  inc c
  ret
fcmp:
  push bc
  call ParseNextFullArg
  ld hl,cmpSingle
  ld (next_page_call_address),hl
  pop hl
  ld d,b
  ld e,c
  jp next_page_call
moreLogic:
  push af
  push bc
  call ParseFullArg
  pop hl
  pop af
  ret
notLogic:
  call MoreLogic
  ld a,b \ cpl \ ld b,a
  ld a,c \ cpl \ ld c,a
  ret
andLogic:
  call MoreLogic
  ld a,h \ and b \ ld b,a
  ld a,l \ and c \ ld c,a
  ret
orLogic:
  call MoreLogic
  ld a,h \ or b \ ld b,a
  ld a,l \ or c \ ld c,a
  ret
xorLogic:
  call MoreLogic
  ld a,h \ xor b \ ld b,a
  ld a,l \ xor c \ ld c,a
  ret
Less:
  ld a,(hl)
  cp $3A
  jr z,flt
  call MoreLogic
  xor a
  sbc hl,bc
  ld b,a
  adc a,a
  ld c,a
  ret
flt:
  call fcmp
  ld bc,0
  ret nc
  inc c
  ret
Greater:
  ld a,(hl)
  cp $3A
  jr z,fgt
  call MoreLogic
  xor a
  scf
  sbc hl,bc
  ccf
  ld b,a
  adc a,a
  ld c,a
  ret
fgt:
  call fcmp
  ld bc,0
  ret z
  ret c
  inc c
  ret
LessOrEqual:
  ld a,(hl)
  cp $3A
  jr z,fle
  call MoreLogic
  xor a
  scf
  sbc hl,bc
  ld b,a
  adc a,a
  ld c,a
  ret
fle:
  call fcmp
  ld bc,1
  ret c
  ret z
  dec c
  ret
MoreOrEqual:
  ld a,(hl)
  cp $3A
  jr z,fge
  call MoreLogic
  xor a
  sbc hl,bc
  ccf
  ld b,a
  adc a,a
  ld c,a
  ret
fge:
  call fcmp
  ld bc,0
  ret c
  inc c
  ret
NotEqual:
  ld a,(hl)
  cp $3A
  jr z,fne
  call MoreLogic
  xor a
  sbc hl,bc
  ld b,a
  ld c,a
  ret z
  inc c
Exit:
  ret
fne:
  call fcmp
  ld bc,0
  ret z
  inc c
  ret
EndOfCommand:
  ld hl,(parsePtr)
  inc hl
  ld a,(hl) \ call EndOArg
  jr nz,EndOfCommand+3
  ld (parsePtr),hl
  ret
EndOArg:
  cp 4 \ ret z  ;->
EndOArgNotSto:
  cp 3Fh \ ret z ;NL
;  cp 3Ah \ ret z
  cp 3Eh \ ret z ;:
  cp 2Bh \ ret z ;,
  or a
  ret
;====================================
;====================================
;This section contains calls and data
;used by Grammer.
;====================================
;====================================
;
;===============================================================
FindEndToken:
;===============================================================
;Input:
;     HL is an address
;Outputs:
;     HL points to the byte after the proper End token
;===============================================================
  ld b,1
SearchEndLoop:
  inc hl
  ld a,(hl)
  sub $CF                  ;Then
  jr c,SearchEndLoop       ;**Just to save time
  jr z,+_
  dec a
  dec a \ jr z,+_   ;While
  dec a \ jr z,+_   ;Repeat
  dec a \ jr z,+_   ;For
  dec a \ jr nz,SearchEndLoop ;End
  djnz SearchEndLoop
  inc hl
  ret
_:
  inc b
  jr SearchEndLoop
FindElseEnd:
;Input:
;     HL is an address
;Outputs:
;     HL points to the byte after the proper Else or End token
;     A is the last token checked
  ld b,0
FindElseEnd_:
  inc b
  inc hl
  ld a,(hl)
  sub $CF           ;Then
  jr c,-_+1
  jr z,-_
  dec a \ jr z,+_
  dec a \ jr z,-_   ;While
  dec a \ jr z,-_   ;Repeat
  dec a \ jr z,-_   ;For
  dec a \ jr nz,FindElseEnd_+1
_:
  djnz FindElseEnd_+1
  ld a,(hl)
  inc hl
  ret

;===============================================================
GetGrammerText:
;===============================================================
;Input:
;    HL points to the start of the string
;Outputs:
;     A is the value of the ending byte of the string
;    BC is the size of the string
;    DE points to the start of the converted string
;    HL points to the ending byte of the string
;     z flag is set
;===============================================================
  ld de,saveSScreen
GetGrammerText_DE:
  ld bc,0
  push de
TextConvert:
  ld a,(hl)
  cp 4   ;->
  jr z,TextConvertEnd
  cp 3Fh    ;newline
  jr z,TextConvertEnd
  cp 2Ah  ;"
  jr z,TextConvertEnd
  call TokToASCII+3
  jp TextConvert
  ld de,OP3
TokToASCII:
;Inputs:
;     HL points to the token
;     DE points to where the token should get converted to
;Outputs:
;     HL is incremented
;     DE points to the byte after the string
;     BC is the size of the string
  ld bc,0
  push hl
  push bc
  push de
  bcall(_Get_Tok_Strng)
  pop de
  pop hl
  add hl,bc
  push hl
  ld hl,OP3
  ldir
  pop bc
  pop hl
  ld a,(hl)
  call Is_2_Byte
  inc hl
  ret nz
  inc hl
  ret
TextConvertEnd:
  inc hl
  pop de
  ret
;;===============================================================
GetGrammerStr:
;;===============================================================
;;Input:
;;    HL points to the start of the string
;;Outputs:
;;     A is the value of the ending byte of the string
;;    BC is the size of the string
;;    HL points to the ending byte of the string
;;     z flag is set
;;===============================================================
  ld bc,0
_:
  inc hl
  inc bc
  ld a,(hl)
  cp 4 \ ret z
  cp 3Fh \ ret z
  cp 2Ah \ jr nz,-_
  inc hl
  ret
VarP:
  cp $AF    ;? token
  jr nz,VarPointer
  ex de,hl
  scf
  ld hl,qmarkVar
  ret
;===============================================================
VarPointer:
;===============================================================
;Inputs:
;     A is the var to return the pointer of
;     hl points to the next byte
;Outputs:
;     A is the lower 8-bits of the pointer
;     BC is not affected
;     DE should be used to update (parsePtr)
;     HL points to the var data
;     c flag is reset if A was not a var token
  cp $BB
  jr nz,NotBBvar
  ld d,h
  ld e,l
  ld a,(hl)
  sub 203
  ret nc
  sub -16
  adc a,10
;  cp 26       ;to be safe, we could include this
  ret nc
  add a,a
  ld hl,pvars+54
  add a,l
  ld l,a
#if (pvars+54)&255>=204
  jr nc,$+3
  inc h
#endif
  inc de
  scf
  ret
NotBBVar:
  cp 'A'
  ccf
  ret nc
  cp 'Z'+2
  ret nc
  sub 'A'
  rlca
  ld d,pvars>>8
  ld e,a
  ld a,(hl)
  cp $AE
  jr nz,+_
  ld a,54
  add a,e
  ld e,a
  inc hl
_:
  ld a,e
  add a,pvars&255
  ld e,a
#if pvars&255>=202
  jr nc,$+3
  inc d
#endif
  ex de,hl
  scf
  ret
;===============================================================
EndOfLine:
;===============================================================
;Input:
;     HL is a pointer
;Output:
;     HL points to the next line
;===============================================================
  ld a,3Fh
  push bc
  ld bc,0
  cpir
  pop bc
  ret
;===============================================================
IsHexTok:
;===============================================================
;Input:
;     DE points to the byte
;Output:
;     DE is incremented by 1
;      A is the hex value if A is a hex token
;     nc if A is a hex token
;      c if A is not a hex token
;===============================================================
  ld a,(de)
  inc de
  cp 47h
  ccf
  ret c
  cp 'A'
  jr nc,+_
  cp 3Ah
  ccf
  ret c
  .db $DA ;start of jp c,**
_:
  sub 7
  sub 30h
  ret
;===============================================================
ConvRStr:
;===============================================================
;Input:
;     DE points to the base 10 number string in RAM.
;Outputs:
;     HL is the 16-bit value of the number
;     DE points to the byte after the number
;     BC is HL/10
;     z flag reset (nz)
;     c flag reset (nc)
;Destroys:
;     A (actually, add 30h and you get the ending token)
;Size:  41 bytes
;Speed: 134+(106+{0,9})n
;       n is the number of digits
;       c is at most n-2
;       at most 691 cycles for any 16-bit decimal value
;===============================================================
  dec hl
  bit baseInput,(iy+UserFlags)
  jp nz,ConvHexStr
  ex de,hl
  ld hl,0
  push de   ;save in case we encounter a float
ConvLoop:
  ld a,(de)
  sub 30h
  cp 10
  jr nc,Convtd
  inc de
  ld b,h
  ld c,l
  add hl,hl
  add hl,hl
  add hl,bc
  add hl,hl
  add a,l
  ld l,a
  jr nc,ConvLoop
  inc h
  jp ConvLoop
Convtd:
  jr z,+_   ;means it was a decimal point
  pop bc
  ld (parsePtr),de
  ld b,h
  ld c,l
  ret
_:
  pop hl
  ;HL points to the string
  dec hl
  ld a,(hl)
  cp $B0     ;neg sign token
  jr nz,+_
  ;Need to pop off the return address; not returning to the neg routine
  pop de
  pop de
  .db $FE   ;start of cp *, causes the inc hl to be ignored
_:
  inc hl
  ;HL points to the float
  push hl
  call floatstackpush
  ld b,h
  ld c,l
  ld hl,str2single
  ld (next_page_call_address),hl
  pop hl
  call next_page_call
  ld hl,(scrap+30)
  ld (parsePtr),hl
  ret
;===============================================================
HL_Times_BC:
;===============================================================
;Inputs:
;     HL and BC are factors
;Outputs:
;     DEHL is the 32-bit value of the product
;     BC is unchanged
;     A is 0
;===============================================================
  ex de,hl
;===============================================================
DE_Times_BC:
;===============================================================
;Inputs:
;     DE and BC are factors
;Outputs:
;     DEHL is the 32-bit value of the product
;     BC is unchanged
;20 bytes
;Speed: 846cc+16{0,13}
;min: 846cc
;max: 1054cc
;avg: 950cc
  ld hl,0
  ld a,e
  ld e,16
_:
  add hl,hl
  rla
  rl d
  jr nc,$+5
  add hl,bc
  adc a,0
  dec e
  jr nz,-_
  ld e,a
  ret
;===============================================================
HL_Div_BC:
;===============================================================
;Performs HL/BC
;Speed:   1182cc (+6cc for every 0bit in the result)
;Size:    29 bytes
;Inputs:
;     DE is the numerator
;     BC is the denominator
;Outputs:
;     HL is the quotient
;     DE is the remainder
;     BC is not changed
;     z flag is set
;     c flag is reset
;===============================================================
  ex de,hl
;===============================================================
DE_Div_BC:
;===============================================================
;Performs DE/BC
;Speed:   1178cc (+6cc for every 0bit in the result)
;Size:    28 bytes
;Inputs:
;     HL is the numerator
;     BC is the denominator
;Outputs:
;     HL is the quotient
;     DE is the remainder
;     BC is not changed
;     z flag is set
;     c flag is reset
;===============================================================
  ld a,e
  ld e,16
  ld hl,0
Div16Loop:
  rla
  rl d
  adc hl,hl
  sbc hl,bc
  jr nc,$+3
  add hl,bc
  dec e
  jr nz,Div16Loop
  rla
  cpl
  ld e,a
  ld a,d
  rla
  cpl
  ld d,a
  ex de,hl
  ret
#include "cmd/searchstring.z80"
;===============================================================
CheckStatus:
;===============================================================
;Speed:  89 cycles
;Size:   13 bytes
;Outputs:
;     z is set if ON is being pressed
;     c is set if 15MHz mode is used
;===============================================================
  push bc
  push af
  in a,(4)
  and 8
  in a,(20)
  rra
  pop bc
  ld a,b
  pop bc
  ret
;===============================================================
GraphToLCD:
;===============================================================
  ld hl,(BufPtr)
  ld ix,(GrayBufPtr)
;===============================================================
BufferToLCD:
;===============================================================
;Input:
;     HL points to the buffer to copy to the LCD
;Outputs:
;
;===============================================================
  di
setrow:
  LCDDelay()
  ld a,$80
  out (16),a
  exx
  ld hl,(GrayMask)
  add hl,hl
  jr nc,$+4
  set 4,l
  ld (GrayMask),hl
  ld bc,(GrayRotate)
  ld a,3
  and c
  ld c,a
  exx
  ld de,12

  LCDDelay()
  ld a,$20
col:
  push af
  pop af
  out (10h),a
  push af
  ld b,64
row:
;(checker AND gray) OR black
;
  exx
  add hl,hl
  jr nc,$+4
  set 4,l
  ld a,h
  exx
  ld c,a
  ld a,(ix)
  xor (hl)
  and c
  xor (hl)
  add hl,de
  add ix,de
  bit InvertLCDFlag,(iy+UserFlags)
  jr z,$+3
  cpl
  ex af,af'
  LCDDelay()
  ex af,af'
  out ($11),a
  exx
  ld b,c
  inc b
  dec b
  jr z,RotateDone
RotateMask:
  add hl,hl
  jr nc,$+4
  set 4,l
  ld a,h
  djnz RotateMask
RotateDone:
  exx
  djnz row
  pop af
  inc a
  dec h
  dec h
  dec h
  inc hl
  dec ixh
  dec ixh
  dec ixh
  inc ix
  cp $2c
  jp nz,col
  ret
;===============================================================
DrawRectToGraph:
;===============================================================
;Inputs:
;     A is the type of rectangle to draw
;        0 =White
;        1 =Black
;        2 =XOR
;        3 =Black border
;        4 =White border
;        5 =XOR border
;        6 =Black border, white inside
;        7 =Black border, XOR inside
;        8 =White border, black inside
;        9 =White border, XOR inside
;        10=Shift Up
;        11=Shift Down
;     B is the height
;     C is the Y pixel coordinate
;     D is the width in pixels
;     E is is the X pixel coordinate
;===============================================================
;RectData  =84A2h
  di
  ex af,af'
;Check if coords are negative
  ld a,c
  or a
  jp p,$+9
  add a,b
  ret nc
  ret z
  ld b,a
  ld c,0
  ld a,e
  or a
  jp p,$+9
  add a,d
  ret nc
  ret z
  ld d,a
  ld e,0
;Check dimensions
  ld a,b
  or a
  ret z
  jp p,$+6
  neg
  ld b,a
  add a,c
  sub 64
  jr c,$+6
  neg
  add a,b
  ld b,a

  ld a,d
  or a
  ret z
  jp p,$+6
  neg
  ld d,a
  add a,e
  sub 96
  jr c,$+6
  neg
  add a,d
  ld d,a
  ld a,c
  cp 64
  ret nc
  ld a,e
  cp 96
  ret nc
MakePattern:
  push bc
  ld hl,RectData
  ld b,24
  xor a
_:
  ld (hl),a
  inc l
  djnz -_
  ld hl,RectData
  ld c,(RectData+12)&255
  ld a,e
_:
  sub 8
  jr c,+_
  inc l
  inc c
  jr -_
_:
  add a,8
  ld b,a
  inc b
  ld e,a
  ld a,d
  add a, e
  ld e,a
  ld a,1
  rrca
  djnz $-1
  ld b,l
  push af
  ld l,c
  or (hl)
  ld (hl),a
  ld l,b
  pop af
  dec a
  scf
  adc a,a
  ld (hl),a
  ld a,e
  sub 8
  jr c,$+10
  jr z,$+10
  inc l
  ld (hl),-1
  inc c
  jr $-10
  add a,8

  ld b,a
  or a
  ld a,1
  jr z,$+5
  rrca
  djnz $-1

  ld b,l
  push af
  ld l,c
  or (hl)
  ld (hl),a
  ld l,b
  pop af
  dec a
  cpl
  and (hl)
  ld (hl),a
  pop bc
  ld a,b
  ld b,0
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  ld bc,(BufPtr0e)
  add hl,bc
  ld b,a
  ex af,af'
  .db $CB,$67,$28,$10,$D6,$10,$F5,$0E,$18,$11
  .dw RectData
  .db $1A,$2F,$12,$13,$0D,$20,$F9,$F1

  or a
  jr nz,$+13h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$2F,$A6,$77,$13,$23,$0D,$20,$F7,$10,$F0,$C9
;dbs1

  dec a
  jr nz,$+12h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$B6,$77,$13,$23,$0D,$20,$F8,$10,$F1,$C9
;dbs2
  dec a
  jr nz,$+12h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$AE,$77,$13,$23
  .db $0D,$20,$F8,$10,$F1,$C9
;dbs3
  dec a
  jr nz,$+26h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$B6,$77,$13,$23,$0D,$20,$F8,$05,$C8
;dbs4
  .db $05,$28,$0F,$0E,$0C,$11
  .dw RectData+12
  .db $1A,$B6,$77,$13,$23,$0D,$20,$F8,$10,$F1,$04,$18,$DC
;dbs5
  dec a
  jr nz,$+28h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$A6,$AE,$77,$13,$23,$0D,$20,$F7,$05,$C8,$05,$28,$10,$0E,$0C,$11
  .dw RectData+12
  .db $1A,$A6,$AE,$77,$13,$23,$0D,$20,$F7,$10,$F0,$04,$18,$DA
;dbs6
  dec a
  jr nz,$+26h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$AE
  .db $77,$13,$23,$0D,$20,$F8,$05,$C8,$05,$28,$0F,$0E,$0C,$11
  .dw RectData+12
  .db $1A,$AE,$77,$13,$23,$0D,$20,$F8
  .db $10,$F1,$04,$18,$DC
;dbs7
  dec a
  jr nz,$+36h
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$B6,$77,$13,$23,$0D,$20,$F8,$05,$C8,$05
  .db $28,$1F,$E5,$0E,$0C,$11
  .dw RectData
  .db $1A,$A6,$AE,$77,$13,$23,$0D,$20,$F7,$E1,$0E,$0C,$11
  .dw RectData+12
  .db $1A
  .db $B6,$77,$13,$23,$0D,$20,$F8,$10,$E1,$04,$18,$CC
;dbs8
  .db $3D,$20,$33,$0E,$0C,$11
  .dw RectData
  .db $1A,$B6,$77,$13
  .db $23,$0D,$20,$F8,$05,$C8,$05,$28,$1E,$E5,$0E,$0C,$11
  .dw RectData
  .db $1A,$AE,$77,$13,$23,$0D,$20,$F8,$E1
  .db $0E,$0C,$11
  .dw RectData+12
  .db $1A,$B6,$77,$13,$23,$0D,$20,$F8,$10,$E2,$04,$18,$CD,$3D,$20,$34,$0E,$0C,$11
  .dw RectData
  .db $1A,$A6,$AE,$77,$13,$23,$0D,$20,$F7,$05,$C8,$05,$28,$1E,$E5,$0E,$0C,$11
  .dw RectData
  .db $1A,$B6
  .db $77,$13,$23,$0D,$20,$F8,$E1,$0E,$0C,$11
  .dw RectData+12
  .db $1A,$AE,$77,$13,$23,$0D,$20,$F8,$10,$E2,$04,$18
  .db $CC,$3D,$20,$35,$0E,$0C,$11
  .dw RectData
  .db $1A,$A6,$AE,$77,$13,$23,$0D,$20,$F7,$05,$C8,$05,$28,$1F,$E5
  .db $0E,$0C,$11
  .dw RectData
  .db $1A,$AE,$77,$13,$23,$0D,$20,$F8,$E1,$0E,$0C,$11
  .dw RectData+12
  .db $1A,$A6,$AE,$77,$13
  .db $23,$0D,$20,$F7,$10,$E1,$04,$18,$CB,$3D,$20,$37,$05,$C8,$F3,$E5,$D9,$01,$0C,$00,$E1,$09,$D9,$0E
  .db $0C,$11
  .dw RectData
  .db $D5,$D9,$D1,$D9,$1A,$2F,$A6,$D9,$47,$1A,$A6,$B0,$13,$23,$D9,$77,$13,$23,$0D,$20
  .db $EF,$10,$E4,$0E,$0C,$11
  .dw RectData
  .db $1A,$2F,$A6,$77,$13,$23,$0D,$20,$F7,$FB,$C9
;dbs9
  .db $3D,$20,$40,$F3,$C5
  .db $11,$0C,$00,$19,$10,$FD,$2B,$E5,$D9,$11,$F4,$FF,$E1,$19,$D9,$C1,$05,$C8,$0E,$0C,$11
  .dw RectData+11
  .db $D5
  .db $D9,$D1,$D9,$1A,$2F,$A6,$D9,$47,$1A,$A6,$B0,$1B,$2B,$D9,$77,$1B,$2B,$0D,$20,$EF,$10,$E4,$0E,$0C
  .db $11
  .dw RectData+11
  .db $1A,$2F,$A6,$77,$1B,$2B,$0D,$20,$F7,$FB,$C9
;dbs10
  dec a
  ret z
  dec a
  ret z
  exx
  ld de,0
  ld c,8
  exx
PxlTestRect:
  dec a
  jr nz,PxlTestBorder
  ld c,12
  ld de,RectData
PxlTstRectLoop:
  call PxlTestWithMask
  djnz PxlTstRectLoop-5
  exx
  ld b,d
  ld c,e
  ret
PxlTestBorder:
  dec a
  ret nz
  ld c,12
  ld de,RectData
  call PxlTestWithMask
  dec b
  jr z,PxlTestBorder-4
  dec b
  jr z,PxlTestBrdrEnd
  ld c,12
  ld de,RectData+12
PxlTstBrdrLoop:
  call PxlTestWithMask
  djnz PxlTstBrdrLoop-5
PxlTestBrdrEnd:
  ld de,RectData
  ld c,12
  call PxlTestWithMask
  exx
  ld b,d
  ld c,e
  ret
PxlTestWithMask:
  ld a,(de)
  and (hl)
  exx
  ld b,c
_:
  add a,a
  jr nc,$+3
  inc de
  jr z,+_
  djnz -_
_:
  exx
  inc de
  inc hl
  dec c
  jr nz,PxlTestWithMask
  ret
PutSS:
  ld d,a
  jr GPutS+2
GPutSS:
  ld (textRow),bc
;===============================================================
GPutS:
;===============================================================
;Inputs:
;     HL points to a zero terminated string to display
;     (textRow) is the pixel row to draw at
;     (textCol) is the text column to draw at (0 to 23)
;Outputs:
;     HL points to the ending byte
;     BC is the size of the string
;     A is 0
;     z flag is set
;     c flag reset
;Destroys:
;     DE
;===============================================================
  ld d,0    ;gotta keep this here for PutSS
  ld bc,0
_:
  ld a,(hl)
  cp d
  ret z
  push de
  inc bc
  push bc
  inc hl
  push hl
  call PutSC
  pop hl
  pop bc
  pop de
  jr -_
;===============================================================
PutSC:
;===============================================================
;Inputs:
;     a is the char to draw
;     (textRow) is the pixel row to draw at
;     (textCol) is the text column to draw at (0 to 23)
;===============================================================
  ld b,a
  ld a,(GrayRotate)
  and 18h
  jp z,+_
  cp 8
  jp z,VPutC
  cp 10h
  jp z,VPutSC
  cp 18h
  jp z,OmniCalcFont
_:
  push bc
  ld bc,(textRow)
  ld a,b
  cp 24
  ld a,c
  jr c,+_
  ld b,0
  add a,6
_:
  cp 3Bh
  jr c,+_
  sub 3Ch
  jr nc,+_
  add a,6
_:
  ld c,a
  inc b
  ld (textRow),bc
  dec b
  ld hl,(FontPointer)
  pop af
;===============================================================
PutFS:
;===============================================================
  push bc
  push hl
  ld b,0
  ld c,a
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  pop de
  add hl,de
  pop bc
  push hl
  ld a,b
  ld b,0
  ld h,b
  ld l,c
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  rra
  push af
  ld c,a
  add hl,bc
  ld bc,(BufPtr)
  add hl,bc
  ld bc,060Ch
;==========================================
;Added in for slow text
  bit SlowTextFlag,(iy+InternalFlag)
  jr z,SkipSlow
  push bc
  push hl
  call GraphToLCD
  pop hl
  pop bc
  ld a,(TextPauseTime)
  ei
_:
  halt
  dec a
  jr nz,-_
  di
SkipSlow:
;==========================================
  pop af
  pop de
  jr c,PutRight
;===============================================================
PutLeft:
;===============================================================
  ld a,(hl)
  and 15
  ld (hl),a
  ld a,(de)
  bit InvertTextFlag,(iy+UserFlags)
  jr z,+_
  cpl
_:
  bit 0,b
  jr z,+_
  rlca \ rlca \ rlca \ rlca
  inc de
_:
  and $F0
  or (hl)
  ld (hl),a
  ld a,b
  ld b,0
  add hl,bc
  ld b,a
  djnz PutLeft
  ret
;===============================================================
PutRight:
;===============================================================
  ld a,(hl)
  and $F0
  ld (hl),a
  ld a,(de)
  bit InvertTextFlag,(iy+UserFlags)
  jr z,+_
  cpl
_:
  bit 0,b
  jr nz,+_
  rlca \ rlca \ rlca \ rlca
  dec de
_:
  inc de
  and 15
  or (hl)
  ld (hl),a
  ld a,b
  ld b,0
  add hl,bc
  ld b,a
  djnz PutRight
  ret
sqrtHL_page0:
;returns HL as the sqrt, DE as the remainder
	ld	a,l
	ld	l,h
	ld	de,$0040
	ld	h,d
	ld	b,8
	or	a
_:
	sbc	hl,de
	jr	nc,$+3
	add	hl,de
	ccf
	rl	d
	rla
	adc	hl,hl
	rla
	adc	hl,hl
	djnz	-_
  ld e,h
  ld l,d
  ld h,b
  ld d,b
  rl d
	ret

;===============================================================
FastCircle:
;===============================================================
  ld l,a
  ld h,-1
  ld (TempWord1),hl
Circle:
;===============================================================
;Input:
;     D = center_x
;     E = center_y
;     C = radius
;     A = method
;Outputs:
;===============================================================
  di
  ld a,c
  or a
  ret z
  ret m
  ld h,c     ;h is radius
  ld l,0
  ld b,-1
  ld (TempWord3),de
DrawLoop:
  ex af,af'
  ld a,(TempWord1+1)
  rlca
  ld (TempWord1+1),a
  jr c,$+8
  call Plot4Pix
  call Plot4Pix
  ex af,af'
  inc l
  inc b \ inc b
  sub b
  jr nc,+_
  add a,c
  add a,c
  dec h
  inc b
_:
  ld d,a
  ld a,h
  sub l
  ld a,d
  jr nc,DrawLoop
  ret
Plot4Pix:
  ld de,(TempWord3)
  ld a,h \ ld h,l \ ld l,a
  ld a,d \ add a,h \ ld d,a
  ld a,e \ add a,l \ ld e,a
  call PixelSet
  push de
  ld a,d \ sub h \ sub h \ ld d,a
  call PixelSet
  ld a,e \ sub l \ sub l \ ld e,a
  call PixelSet
  pop de
  ld a,e \ sub l \ sub l \ ld e,a
PixelSet:
;     DE = (x,y)
  ld a,(TempWord1)
  push de
  exx
  pop bc
  ld d,a
  call PlotPixel
  exx
  ret
SetMem:
  ld (hl),a
  cpi
  jp pe,SetMem
  ret
;===============================================================
Is_2_Byte:
;===============================================================
  cp $EF \ ret z
  cp $BB \ ret z
  cp $7E \ ret z
Is_Var_Name:
  sub $AA \ ret z     ;AA
  add a,$47 \ ret z   ;63
  inc a \ ret z
  inc a \ ret z
  inc a \ ret z
  add a,2 \ ret z
  inc a \ ret z
  inc a \ ret
RAMCodeStart:
  push af
  nop
  or (hl)
  ld (hl),a
  pop af
  ret
L7151:
  push hl
  push af
  ld a,0
  dec a
  jr L7171
L7158:
  ld a,$80
  xor (iy+InternalFlag)
  ld (iy+InternalFlag),a
  ld hl,$811a
_:
  ld a,(ix-1)
  inc a
  jr nz,+_
  ld (hl),0
  jr -_
_:
  dec (hl)
  dec a
  jr z,L7158
L7171:
  ld ($8109),a
  pop af
  pop hl
  ret
;SetLinePixCode:
; push af   ; Saving A
; ld a,(ix+0)
; cpl
; xor c   ; Writing pixel to current position
; nop
; ld (ix+0),a
; pop af   ; Recalling A
; ret

_:
IncHLMem1 = -_-RAMCodeStart+ramCode
  inc h
  ret po
  ld h,a
  in a,(6)
  inc a
  out (6),a
  ld a,h
  ld h,40h
  ret
_:
call_previous_page = -_-RAMCodeStart+ramCode
  ld (de_restore),de
  ex (sp),hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl      ;the return address
  ld (page0_call),de
  ex (sp),hl
  push af
  in a,(6)
  inc a
  out (6),a
  pop af
de_restore = $-RAMCodeStart+ramCode+1
  ld de,0
page0_call = $-RAMCodeStart+ramCode+1
  call 0
  push af
  in a,(6)
  dec a
  out (6),a
  pop af
  ret
_:
call_next_page = -_-RAMCodeStart+ramCode
  ld (de_restore_),de
  ex (sp),hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl      ;the return address
  ld (page1_call),de
  ex (sp),hl
  push af
  in a,(6)
  dec a
  out (6),a
  pop af
de_restore_ = $-RAMCodeStart+ramCode+1
  ld de,0
page1_call = $-RAMCodeStart+ramCode+1
  call 0
  push af
  in a,(6)
  inc a
  out (6),a
  pop af
  ret
_:
next_page_call = -_-RAMCodeStart+ramCode
  push af
  in a,(6)
  dec a
  out (6),a
  pop af
next_page_call_address = $-RAMCodeStart+ramCode+1
  call 0
  push af
  in a,(6)
  inc a
  out (6),a
  pop af
  ret
_:
prev_page_call = -_-RAMCodeStart+ramCode
  push af
  in a,(6)
  inc a
  out (6),a
prev_page_call_address = $-RAMCodeStart+ramCode+1
  call 0
  in a,(6)
  dec a
  out (6),a
  ret
_:
bincompare = -_-RAMCodeStart+ramCode
  ld de,(parsePtr)
  out (6),a
  .db $FE   ;start of cp *
_:
  inc de
  ld a,(de)
  cp (hl)
  jr nz,+_
  call isEOT
  jr z,+_
  inc l \ call z,incHLMem1
  ld a,(hl)
  or a
  jr nz,-_
_:
  in a,(6)
  ld b,a
;  push af
_:
bincomparepagerestore = -_-RAMCodeStart+ramCode+1
  ld a,0
  out (6),a
;  pop af
  ld a,b
  ret
isEOT    = $-RAMCodeStart+ramCode
;End Of Token includes (, ' ', {, [, \n, :
  or a \ ret z
  cp $10 \ ret z  ;(
  cp $29 \ ret  ;space
RamCodeEnd:
.echo "RamCode : ",$-RamCodeStart
;=============================================================================
ConvOP1:
  ld hl,OP1
convFloat:
;Inputs: HL points to the TI Float.
;Outputs: The float is converted to a 16-bit integer held in DE, or LSB in A.
;68cc if not a number
;93cc          on (0,1)
;154.140625cc  on [1,10) or 0
;324.5159375cc on [10,100)
;435.6565625cc on [100,1000)
;540.031875cc  on [1000,10000)
;651.1725cc    on [10000,100000)
;118cc         if >=100000
;Average for integers on [0,65535]: ~632.43cc
  call +_
  ld a,e
  ret
_:
  xor a
  ld d,a
  ld e,a
  or (hl)
  and 31
  ret nz
  inc hl
  ld a,(hl)
  sub 80h
  ret c
  inc hl
  jr z,lastdigit2
  cp 5
  ret nc
  ld b,a

_:
  ;multiply DE by 100
  ex de,hl
  ld a,b
  sla l
  add hl,hl
  ld b,h
  ld c,l
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,bc
  ex de,hl
  ld b,a
  call convBCDbyte
  inc hl
  dec b
  ret z
  djnz -_
lastdigit:
  ex de,hl
  ld b,h
  ld c,l
  add hl,hl
  add hl,hl
  add hl,bc
  add hl,hl
  ex de,hl
lastdigit2:
;49+{0,8
;min: 49cc
;max: 57cc
;avg: 49+8*4.5/256 = 49.140625
  ld a,(hl)
  rrca
  rrca
  rrca
  rrca
  and 15
  add a,e
  ld e,a
  ret nc
  inc d
  ret
convBCDbyte:
;min: 60cc
;max: 68cc
;avg: 60+8*(99*98/2/100)/256 = 61.5159375cc
  ld a,(hl)   ;\ I feel particularly proud of this code, so feel free to use it ^~^
  and $F0     ; |It converts a byte of BCD to an 8-bit int.
  rra         ; |The catch is, I only have A and C to use, and (hl) is the BCD
  ld c,a      ; |number.
  rra         ; |If you come up with faster, please let me know and post it in
  rra         ; |the optimized routines thread on popular TI forums.
  sub a,c     ; |Algo: Multiply upper digit by -6, add the original byte.
  add a,(hl)  ;/ Result is upper_digit*(-6+16)+lower_digit. Ha, repost.
  add a,e
  ld e,a
  ret nc
  inc d
  ret
GetPixelLoc:
;Input:
;     b is X
;     c is y
;Output:
;     HL points to byte
;     A is the mask
;     nc if not computed, c if computed
  ld a,c
  cp 64
  ret nc
  ld a,b
  cp 96
  ret nc
  ld l,c
  ld h,0
  ld b,h
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  ld c,a
  srl c
  srl c
  srl c
  add hl,bc
  ld bc,(BufPtr0e)
  add hl,bc
  and 7
  ld b,a
  inc b
  ld a,1
  rrca
  djnz $-1
  scf
  ret
ConvHexTo86ECh:
;max: 174n+91
;min: 128n+56
;avg: 145.25x+79    (typical avg, assuming most end in newline)
;An 8x8 sprite is now 6% faster on avg. than versions <2.50
  ld d,b
  ld e,c
  ld hl,86ECh
  ld bc,$0A30
ConvHexLoop7:
;  HL points to where to convert
;  DE is where to convert from
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  ld a,(de)
  inc de
  sub c
  ret c
  cp b
  jr c,+_
  sub 17
  ret c
  cp 6
  ret nc
  add a,b
_:
  rld
  inc hl
  jp ConvHexLoop7
IsConditional:
  cp $D8 \ ret z      ;pause
  cp $CE \ ret z      ;if
  cp $D1 \ ret z      ;while
  cp $D2 \ ret        ;repeat
SetUpData:
  bcall(_RunIndicOff)
  call setupRAMdata
#ifndef include_TSA
  ld hl,ReadArcData
  ld de,TSA
;mov 70 bytes
  call mov14
  call mov14
  call mov14
  call mov14
  call mov14
  in a,(6)
  ld (page_restore),a
  ld (bincomparepagerestore),a
#endif

  ld hl,floatstack_bottom
  ld (floatstack_ptr),hl
  ld hl,seed2+1
  set 6,(hl)
  dec l
  dec l
  ld a,r \ xor (hl) \ ld (hl),a
  ld hl,plotSScreen
  ld (BufPtr),hl
  ld (GrayBufPtr),hl
  ld hl,PBuf
  ld (PBufPtr),hl
  ld hl,766
  ld (PBuf),hl
  ld a,3
  ld (OutputLogic),a
  ld (TextPauseTime),a
  ld hl,FontSet
  ld (FontPointer),hl
  xor a
  ld (module_count),a
  ld h,a
  ld l,a
  ld (flags+33),hl
  ld (flags+34),hl
  ld (IntLoc),hl
  ld (PBufType),hl
  ld (GrayRotate),hl
  ld hl,5555h
  ld (GrayMask),hl
  pop hl
  ld (SPSave),sp
  jp (hl)
setupRAMdata:
;not speed critical
  ld de,8100h
  ld hl,RAMCodeStart
  ld bc,RAMCodeEnd-RAMCodeStart
  ldir
  ret
EraseParticle:
  ld c,(hl)
  inc hl
  ld b,(hl)
;pixel off
  push bc
  call GetPixelLoc
  pop bc
  ret
TokenSet:
#ifdef include_LoadTSA
#include "cmd/loadtsa.z80"
#endif
isStartMenu_valid:
  ld a,(OP1+1)
  cp $23
  jr z,+_
  cp $21
  jr z,+_
  ld hl,(VATPtr)
  ld a,(hl)
  cp 1        ;don't want lists
  jr nz,$+4
_:
  or a
  ret
  cp 13       ;don't want complex lists
  jr z,-_
  cp 17h      ;don't want GroupVars
  jr z,-_

  bit 6,(iy+UserFlags)     ;must be AppV
  jr z,+_
  cp 15h
  ret nz
_:
;need to pull in six bytes
#ifdef include_LoadTSA
  call LoadReadArc
#endif
  ld bc,-3
  add hl,bc
  ld e,(hl)
  dec hl
  ld d,(hl)
  dec hl
  ld a,(hl)
  or a
  jr z,+_
  ld b,a
  dec hl
  ld a,(hl)
  add a,10
  add a,e
  ld e,a
  ld a,b
  jr nc,+_
  inc d
  jp po,+_
  inc a
  ld d,$40
_:
  ex de,hl
  ld de,cmdShadow
  ld bc,2
  call TSA
  ld bc,(cmdShadow)
  ;need to save A:HL, BC
  ld (TempWord3),a
  ld (TempWord4),bc
  ld (TempWord5),hl
_:
  ld bc,4
  call TSA
  ld hl,cmdShadow+2
  bit OnBlockFlag,(iy+UserFlags)   ;ASM only
  jp nz,asm_header_only
;non-ASM and ASM alike
  bit baseInput,(iy+UserFlags)
  ret z   ;doesn't have any special filters
;must be a Grammer Var
;header is either $BB,$6D,$55,$C9 or $3A,$30,$3E
  ld a,(hl) \ cp $BB \ jr z,+_
  cp $3A \ ret nz
  inc hl \ ld a,(hl) \ cp $30 \ ret nz
  inc hl \ ld a,(hl) \ cp $3E \ ret
_:
  inc hl \ ld a,(hl) \ cp $6D \ ret nz
  inc hl \ ld a,(hl) \ cp $55 \ ret nz
  inc hl \ ld a,(hl) \ cp $C9
  ret
asm_header_only:
;first two bytes must be $BB,$6D
;
  ld a,(hl) \ cp $BB \ ret nz
  inc hl \ ld a,(hl) \ cp $6D \ ret nz
  bit baseInput,(iy+UserFlags)
  ret z
;next two bytes must be $55,$C9
;
  inc hl \ ld a,(hl) \ cp $55 \ ret nz
  inc hl \ ld a,(hl) \ cp $C9
  ret
CompatCall:
  call setupRAMdata
IsOP1GrammerProg:
  ld (iy+UserFlags),8
  bcall(_ChkFindSym)
  ld (VATPtr),hl
  jp nc,isStartMenu_valid
  or 1
  ret
#ifdef include_LoadTSA
ReadArc:
  call LoadReadArc
  jp TSA
#else
ReadArc = TSA
#endif
ReadArcData:
#ifdef include_loadTSA
  .dw ReadArcEnd-ReadArc-2
#endif
#include "readarc.z80"
ReadArcEnd:
FindGVarData:
  ld hl,GVarData
  rst rMov9ToOP1
  bcall(_ChkFindSym)
  ret nc
  ld hl,3
  bcall(_CreateAppVar)
  ret
GrammerHook:
  .db 83h
  or a
  jr z,$+4
exithook3:
  cp a
  ret
  di
  push hl
  push de
  push bc
  push af
  ld de,(progstart)
  ld a,(de)
  cp $5F      ;make sure it is the prgm Token. I just realized that in older versions, you could have any 1-byte token instead of the prgm token!
  jr z,$+8
_:
  pop af
  pop bc
  pop de
  pop hl
  jr exithook3
  ld hl,(progend)
  sbc hl,de
  inc de
  ld b,h
  ld c,l
  ld a,h
  or a
  jr z,$+5
  ld bc,8
  ld a,c
  or a
  jr z,-_
  cp 9
  jr c,$+4
  ld c,8
  ex de,hl
  ld de,OP1
  ld a,5
  ld (de),a
  inc de
  ldir
  xor a
  ld (de),a
  call SetUpData
  call IsOP1GrammerProg
  jr nz,+_
  ld hl,OP1
  ld de,OP5
  call mov9
  pop af
  pop bc
  pop de
  pop hl
  call SelectedProg
  or 1
  ret
_:
  ld hl,cmdShadow+2             ;location of header
; ION =BB6DC918
; MOS =BB6DC901
; DCS7=BB6DAAC9
; Gram=BB6D55C9
  ld a,(hl) \ cp $BB \ jp nz,HookEnd
  inc hl \ ld a,(hl) \ cp $6D \ jp nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9 \ jp z,MOSIONErr
  ld c,a
  inc hl \ ld a,(hl) \ cp $C9 \ jp nz,HookEnd
  ld a,c \ cp $AA \ jp z,DCSErr
#ifdef SHELL_BROKEN
  jp GramErr
#endif
HomeRunASM:

  ld hl,(TempWord5) \ ld bc,(TempWord4)
  jr nz,$+6
;===============================================================
  inc hl \ inc hl \ dec bc \ dec bc
  inc hl \ inc hl \ dec bc \ dec bc
  ld de,9D94h
  or a \ sbc hl,de
  add hl,de
  ld de,OP1
  jr nz,+_
  pop hl \ pop hl \ pop hl \ pop hl
  xor a
  ret
_:
  ldir
  xor a
  ld (de),a
  ld a,5
  ld (OP1),a
  call SetUpData+3
  call IsOP1GrammerProg
  jr nz,EndHook

  ld hl,OP1
  ld de,OP1+44
  call mov9
  pop af
  pop bc
  pop de
  pop hl
  call SelectedProg
  or 1 \ ret
EndHook:
  ld hl,cmdShadow+2             ;location of header
; ION =BB6DC918
; MOS =BB6DC901
; DCS7=BB6DAAC9
; Gram=BB6D55C9
  ld a,(hl) \ cp $BB \ jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $6D \ jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9
  jr z,HookEnd
  ld a,55h
  cp (hl)
  jr nz,HookEnd
  inc hl \ ld a,(hl) \ cp $C9
  jr c,$+3
  add hl,bc
  push hl \ push bc
  ld h,b \ ld l,c
  bcall(_EnoughMem)
  jp c,ErrMEM
  ex de,hl
;HL # bytes
;DE addr
  ld de,9D95h ;start VarRAM
  push de
  bcall(_InsertMem)
  pop de \ pop bc \ pop hl
  ld a,(TempWord3)
  push de \ push bc
  call ReadArc
  ld hl,0
  add hl,sp
  ld (SPSave),hl
  call 9D95h ;start VarRAM
  pop de \ pop hl
;Delmem: HL address
;        DE # of bytes
  bcall(_DelMem)
;===============================================================
  or 1
;HookEnd-6 Label ------ !!!!
  pop hl
  ld a,h
  pop bc
  pop de
  pop hl
  ret
HookEnd:
  xor a
  jr HookEnd-6
GetVarName:
  call ParseFullArg
  ld h,b
  ld l,c
GetVarName_:
  ld a,(hl)
  and 1Fh
  ld de,OP1
  sub 5 \ jp z,GetGrammerText+3
  dec a \ jp z,GetGrammerText+3
  sub 15 \ jp z,GetGrammerText+3
  dec a \ jp z,GetGrammerText+3
  ld bc,3
  ld d,h \ ld e,l
  add hl,bc
  cp a
  ret
GetVarInfo:
;Returns name in OP1
;A is the flashpage
;HL points to SymEntry
;DE points to size bytes
;BC is the length of the name (for use when finding archived data)
;nc if it exists
;z if it is in RAM
  call GetVarName
GetVarInfo_:
  ex de,hl
  ld de,OP1
  push bc
  ldir
  xor a
  ld (de),a
  bcall(_ChkFindSym)
  ld a,b
  pop bc
  ret c
  or a
  ret
GetvarInfo2:
;Inputs:
;     The next argument to parse points to the name of the var to get info about
;Outputs:
;     A is the ending page (start of data)
;     BC is the size of the var
;     DE points to the SymEntry
;     HL points to the data
;     c is set if the var does not exist
#ifdef include_LoadTSA
  call LoadReadArc
#endif
  call GetVarInfo
  ret c
GetVarInfoVarFound:
  ex de,hl
  or a
  jr nz,+_
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ret
_:
  add hl,bc
  ld c,9
  add hl,bc
  bit 7,h
  jr z,+_
  ld h,40h
  inc a
_:
  push de
  ld de,OP2
  ld bc,2
  call TSA
  ld bc,(OP2)
  pop de
  or a
  ret
;=====================================================
TileMap1:
;=====================================================
;Inputs:
;     DE=MapLoc
;     BC=TileLoc
;     HL=MapWidth
;     A=TileLogic
;     (TempWord2)=Map X
;     (TempWord3)=Map Y
;=====================================================
  and 7
  ld (TempWord1),a
  cp 7
  jr nz,+_
  ld a,(flags+33)
  xor 16
  ld (flags+33),a
_:
  push bc
  push hl
  push de
  ld bc,(TempWord3)
  call HL_Times_BC
  ld bc,(TempWord2)
  add hl,bc
  pop bc \ add hl,bc
  ex (sp),hl ;edited in 2.50.0.2
  ld de,-12  ;
  add hl,de  ;
  pop de     ;
  ld (TempWord2),hl
  xor a
  ld (TempWord1+1),a
  pop bc
;DE points to first Map Element
;(TempWord2) is the map width thing
;BC points to the sprite data
TileMap1loop:
  ld h,12
  ld a,(de) \ inc de
  dec h
  jr nz,DrawNextTile
  ld hl,(TempWord2)
  add hl,de
  ex de,hl
  ld h,12
DrawNextTile:
  push hl
  ld h,0 \ ld l,a
  add hl,hl
  add hl,hl
  add hl,hl
  ld a,(TempWord1)
  cp 7
  jr nz,$+3
  add hl,hl
  add hl,bc
  ld a,(TempWord1+1)
  call DrawTile
  ld (TempWord1+1),a
  pop hl
  jr nz,TileMap1Loop+2
  ret
DrawTile:
;Input:
;     A is the tile number to draw
;     HL points to the sprite data
;Output:
;     A is incremented by 1
;     BC is not changed
;     DE is not changed
;     HL is not changed
;     z flag set if A is 96
; jr $
  sub 96
  ret nc
  push af
  push hl
  push de
  push bc
  ex de,hl
;DE points to sprite
  ld hl,(BufPtr)
  ld bc,768
  add hl,bc
  ld bc,-96
  add hl,bc
  add a,12
  jr nc,$-3
  ld c,a
  inc b
  add hl,bc
  ld bc,0108h
  ld a,(TempWord1)
  call DrawSpriteXxY
  pop bc
  pop de
  pop hl
  pop af
  add a,97
  ret
OmniCalcFont:
;Inputs:
;    B is the char to draw
  ld l,b
  ld h,0
  ld b,h
  ld c,l
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,bc
  ld bc,(FontPointer)
  add hl,bc
  ld de,OP1
  ld b,7
_:
  ld a,(hl)
  rlca
  rlca
  rlca
  ld (de),a
  inc e
  inc hl
  djnz -_
  ld de,OP1
  ld hl,0706h
  jr VputSCStepIn
VPutSC:
;Inputs:
;    B is the char to draw
  ld a,b
  cp 20h
  ld hl,(FontPointer)
  ld c,b
  ld b,0
  add hl,bc
  add hl,bc
  add hl,bc ;*3
  ld de,OP1
  ld b,3  ;3*2 Nibbles
_:
  ld a,(hl)
  and $F0
  ld (de),a
  inc e
  ld a,(hl)
  rrca \ rrca
  rrca \ rrca
  and $F0
  ld (de),a
  inc e
  inc hl
  djnz -_
  ld de,OP1
  ld hl,0604h
  jr VputSCStepIn
VPutC:
;Inputs:
;    B is the char to draw
  ld hl,(FontPointer)
  ld de,255
_:
  inc e
  add hl,de
  ld a,(hl)
  ;a is w,h in nibbles
  and 15 ;height
  inc a  ;1..16 is enough
  ld e,a
  djnz -_
  ld d,e  ;height->d
  ld e,(hl) ;now width
  srl e \ srl e
  srl e \ srl e ;->low nibble, width 0..9
  inc hl
  ex de,hl
VputSCStepIn:
  push hl
  ld bc,(TextRow)
  ld a,b \ add a,l
  cp 97
  jr c,+_
  ld a,c
  add a,h \ ld c,a
  ld a,l \ ld b,0
_:
  ld l,a
  ld a,c
  cp 58
  jr c,+_
  xor a
  ld c,a
_:
  ld h,l
  ld l,a
CoordAdj:
  ld (TextRow),hl
  pop hl
  ld a,(OutputLogic)
  jp DrawPixelCoordSprite
SearchLine:
;Inputs:
;     HL points to the start
;     BC is the number of bytes to search
;     DE is the line number
;     A is the line byte
;Outputs:
;     A is not changed
;     BC is the number of bytes left for the search
;     DE points to the line
;     HL is the length of the line
;===============================================================
  inc bc
  dec de \ inc d \ inc e
  or a
_:
  ld (TempWord1),hl
  cpir
  jp po,+_
  dec e \ jr nz,-_
  dec d \ jr nz,-_
_:
  scf
  ld de,(TempWord1)
  sbc hl,de
  ret

GPutSI:
;     The string to display immediately follows the call
;       The string is zero terminated
;Outputs:
;     All registers are preserved
  ex (sp),hl
  push de \ push bc \ push af
  call GPutS \ inc hl
  pop af \ pop bc \ pop de
  ex (sp),hl
  ret
DrawRectToGraphI:
  ex (sp),hl
;  push de \ push bc \ push af
  ld e,(hl) \ inc hl
  ld c,(hl) \ inc hl
  ld b,(hl) \ inc hl
  ld d,(hl) \ inc hl
  ld a,(hl) \ inc hl
  ex (sp),hl
  jp DrawRectToGraph
;  pop hl \ pop af \ pop bc \ pop de
;  ex (sp),hl
;  ret
TokenHook:
  .db $83
  inc b
  dec b
  ret nz
  push hl
  ld hl,(iMathPtr1)
  inc hl
  inc hl
  ld a,3Ah
  cp (hl)
  jr nz,ChkByte2-2
  inc hl
  ld a,30h
  cp (hl)
  jr nz,ChkByte2-2
  inc hl
  ld a,3Eh
  cp (hl)
  jr nz,ChkByte2-2
  ld hl,TokenTable
  ld b,0
TokenSearchLoop:
  ld a,e
  cp (hl)
  inc hl
  jr z,ChkByte2
NotTokenMatch:
  inc hl
  ld c,(hl)
  inc c
  add hl,bc
  ld a,(hl)
  or a
  jr nz,TokenSearchLoop
  pop hl
  ret
ChkByte2:
  ld a,d
  cp (hl)
  jr nz,NotTokenMatch
  ex (sp),hl
  pop hl
  ld de,OP1
  push de
  inc hl
  ld c,(hl)
  inc c \ inc c
  dec hl
  ldir
  pop hl
  ret
NoChange:
TokenTable:
; .db $02,0,7,"module."
 .db $02,0,1,$F2    ;$
 .db $06,0,8,5,"lFactor"
 .db $28,0,7,"Insert("
 .db $36,0,7,"ClrPart"
 .db $38,0,7,"RunPart"
 .db $3A,0,8,"AddPart("
 .db $3C,0,9,"PartType("
 .db $44,0,5,"Misc("
 .db $58,0,1,5Fh
 .db $BE,0,5,"call "
 .db $38,1,5,"Rect("
 .db $3C,1,5,"Tile("
 .db $3E,1,7,"Sprite("
 .db $40,1,8,"TileMap("
 .db $48,1,9,"Contrast("
 .db $4E,1,9,"ShiftBuf("
 .db $62,1,7,"WriteB("
 .db $70,1,4,"Inv("
 .db $72,1,7,"WriteW("
 .db $A6,1,4,"For "
 .db $B4,1,7,"GetInc("
 .db $BC,1,7,"SetBuf("
 .db $C0,1,8,"SetFont("
 .db $CE,1,8,"MakeVar("
 .db $D0,1,8,"FindVar("
 .db $7E,1,2,"2^"
 .db $72,4,4,"gbuf"
 .db 0
;===================================================
CommandJumpTable:
 .dw ErrBadToken      ; $00
 .dw module           ; $01 ;>DMS
 .dw ErrBadToken      ; $02
#ifdef include_prime
 .dw FracToken        ; $03
#else
  .dw ErrBadToken     ; $03
#endif
 .dw StoToken         ; $04
 .dw ErrBadToken      ; $05
 .dw SetData          ; $06
 .dw ExecLine_        ; $07
 .dw LeftBracket      ; $08
 .dw Ret              ; $09
 .dw ErrBadToken      ; $0A
 .dw ErrBadToken      ; $0B
 .dw ErrBadToken      ; $0C
 .dw Squared          ; $0D
 .dw ErrBadToken      ; $0E
 .dw ErrBadToken      ; $0F
 .dw LeftParantheses  ; $10
 .dw Ret              ; $11
 .dw ErrBadToken      ; $12
 .dw PxlTestToken     ; $13
 .dw Augment          ; $14
 .dw ErrBadToken      ; $15
 .dw ErrBadToken      ; $16
 .dw ErrBadToken      ; $17
 .dw ErrBadToken      ; $18
 .dw MaxToken         ; $19
 .dw MinToken         ; $1A
 .dw RToPr            ; $1B
 .dw RToPTheta        ; $1C
 .dw PToRX            ; $1D
 .dw PToRy            ; $1E
 .dw ErrBadToken      ; $1F
 .dw ErrBadToken      ; $20
 .dw ErrBadToken      ; $21
 .dw SolveSet         ; $22
 .dw ErrBadToken      ; $23
 .dw ErrBadToken      ; $24
 .dw ErrBadToken      ; $25
 .dw ErrBadToken      ; $26
 .dw ErrBadToken      ; $27
 .dw ErrBadToken      ; $28
 .dw Incptr           ; $29
 .dw QuoteToken       ; $2A
 .dw Ret              ; $2B
 .dw OSVarToken       ; $2C
 .dw factorialToken   ; $2D
 .dw ErrBadToken      ; $2E
 .dw ErrBadToken      ; $2F
 .dw ConvRStr         ; $30
 .dw ConvRStr         ; $31
 .dw ConvRStr         ; $32
 .dw ConvRStr         ; $33
 .dw ConvRStr         ; $34
 .dw ConvRStr         ; $35
 .dw ConvRStr         ; $36
 .dw ConvRStr         ; $37
 .dw ConvRStr         ; $38
 .dw ConvRStr         ; $39
 .dw SkipLine         ; $3A
 .dw Base2Num         ; $3B
 .dw orLogic          ; $3C
 .dw xorLogic         ; $3D
 .dw Ret              ; $3E
 .dw NewLine          ; $3F
 .dw andLogic         ; $40
 .dw VarToken         ; $41
 .dw VarToken         ; $42
 .dw VarToken         ; $43
 .dw VarToken         ; $44
 .dw VarToken         ; $45
 .dw VarToken         ; $46
 .dw VarToken         ; $47
 .dw VarToken         ; $48
 .dw VarToken         ; $49
 .dw VarToken         ; $4A
 .dw VarToken         ; $4B
 .dw VarToken         ; $4C
 .dw VarToken         ; $4D
 .dw VarToken         ; $4E
 .dw VarToken         ; $4F
 .dw VarToken         ; $50
 .dw VarToken         ; $51
 .dw VarToken         ; $52
 .dw VarToken         ; $53
 .dw VarToken         ; $54
 .dw VarToken         ; $55
 .dw VarToken         ; $56
 .dw VarToken         ; $57
 .dw VarToken         ; $58
 .dw VarToken         ; $59
 .dw VarToken         ; $5A
 .dw VarToken         ; $5B
 .dw VarName          ; $5C
 .dw VarName          ; $5D
 .dw VarName          ; $5E
 .dw prgmToken        ; $5F
 .dw VarName          ; $60
 .dw VarName          ; $61
 .dw VarName          ; $62
 .dw ErrBadToken      ; $63
 .dw ErrBadToken      ; $64
 .dw ErrBadToken      ; $65
 .dw ErrBadToken      ; $66
 .dw ErrBadToken      ; $67
 .dw ErrBadToken      ; $68
 .dw ErrBadToken      ; $69
 .dw Equals           ; $6A
 .dw Less             ; $6B
 .dw Greater          ; $6C
 .dw LessOrEqual      ; $6D
 .dw MoreOrEqual      ; $6E
 .dw NotEqual         ; $6F
 .dw Add              ; $70
 .dw SubtractToken    ; $71
 .dw AnsToken         ; $72
 .dw FixToken         ; $73
 .dw ErrBadToken      ; $74
 .dw FullToken        ; $75
 .dw FuncToken        ; $76
 .dw ErrBadToken      ; $77
 .dw ErrBadToken      ; $78
 .dw ErrBadToken      ; $79
 .dw ErrBadToken      ; $7A
 .dw ErrBadToken      ; $7B
 .dw ErrBadToken      ; $7C
 .dw ErrBadToken      ; $7D
 .dw ErrBadToken      ; $7E
 .dw ErrBadToken      ; $7F
 .dw ErrBadToken      ; $80
 .dw ErrBadToken      ; $81
 .dw Multiply         ; $82
 .dw Skipline+6       ; $83
 .dw ErrBadToken      ; $84
 .dw ClrDrawToken     ; $85
 .dw ErrBadToken      ; $86
 .dw ErrBadToken      ; $87
 .dw ErrBadToken      ; $88
 .dw ErrBadToken      ; $89
 .dw ErrBadToken      ; $8A
 .dw ErrBadToken      ; $8B
 .dw ErrBadToken      ; $8C
 .dw ErrBadToken      ; $8D
 .dw ErrBadToken      ; $8E
 .dw ErrBadToken      ; $8F
 .dw ErrBadToken      ; $90
 .dw ErrBadToken      ; $91
 .dw ErrBadToken      ; $92
 .dw TextToken        ; $93
 .dw ErrBadToken      ; $94
#ifdef include_ncr
 .dw nCrToken         ; $95
#else
 .dw ErrBadToken      ; $95
#endif
 .dw ErrBadToken      ; $96
 .dw ErrBadToken      ; $97
 .dw StorePicToken    ; $98
 .dw RecallPicToken   ; $99
 .dw ErrBadToken      ; $9A
 .dw ErrBadToken      ; $9B
 .dw LineToken        ; $9C
 .dw VerticalToken    ; $9D
 .dw PtOn             ; $9E
 .dw PtOff            ; $9F
 .dw PtChange         ; $A0
 .dw PxlTokens        ; $A1
 .dw PxlTokens        ; $A2
 .dw PxlTokens        ; $A3
 .dw ShadeToken       ; $A4
 .dw CircleToken      ; $A5
 .dw HorizontalToken  ; $A6
 .dw TangentToken     ; $A7
 .dw ErrBadToken      ; $A8
 .dw ErrBadToken      ; $A9
 .dw VarName          ; $AA
 .dw RandToken        ; $AB
 .dw PiToken          ; $AC
 .dw GetKeyToken      ; $AD
 .dw Incptr           ; $AE
 .dw VarToken         ; $AF
 .dw Negative         ; $B0
 .dw int              ; $B1
 .dw absToken         ; $B2
 .dw ErrBadToken      ; $B3
 .dw ErrBadToken      ; $B4
 .dw ErrBadToken      ; $B5
 .dw ErrBadToken      ; $B6
 .dw ErrBadToken      ; $B7
 .dw notLogic         ; $B8
 .dw iPart            ; $B9
 .dw ErrBadToken      ; $BA
 .dw BBTokens         ; $BB
 .dw Sqrt             ; $BC
 .dw ErrBadToken      ; $BD
 .dw LnToken          ; $BE
 .dw PowerOf2         ; $BF
 .dw ErrBadToken      ; $C0
 .dw ErrBadToken      ; $C1
 .dw Sin              ; $C2
 .dw ErrBadToken      ; $C3
 .dw Cos              ; $C4
 .dw ErrBadToken      ; $C5
 .dw ErrBadToken      ; $C6
 .dw ErrBadToken      ; $C7
 .dw ErrBadToken      ; $C8
 .dw ErrBadToken      ; $C9
 .dw ErrBadToken      ; $CA
 .dw ErrBadToken      ; $CB
 .dw ErrBadToken      ; $CC
 .dw ErrBadToken      ; $CD
 .dw IfToken          ; $CE
 .dw ParserNext       ; $CF
 .dw ElseToken        ; $D0
 .dw WhileToken       ; $D1
 .dw RepeatToken      ; $D2
 .dw ForToken         ; $D3
 .dw EndToken         ; $D4
 .dw Return           ; $D5
 .dw LblToken         ; $D6
 .dw GotoToken        ; $D7
 .dw PauseToken       ; $D8
 .dw StopToken        ; $D9
 .dw ISToken          ; $DA
 .dw ErrBadToken      ; $DB
 .dw InputToken       ; $DC
 .dw ErrBadToken      ; $DD
 .dw DispToken        ; $DE
 .dw DispGraph        ; $DF
 .dw OutputToken      ; $E0
 .dw ClrHomeToken     ; $E1
 .dw FillToken        ; $E2
 .dw ErrBadToken      ; $E3
 .dw ErrBadToken      ; $E4
 .dw ErrBadToken      ; $E5
 .dw Menu             ; $E6
 .dw SendToken        ; $E7
 .dw GetToken         ; $E8
 .dw ErrBadToken      ; $E9
 .dw ErrBadToken      ; $EA
 .dw ExecLine         ; $EB
 .dw Byte             ; $EC
 .dw Word             ; $ED
 .dw ErrBadToken      ; $EE
 .dw ErrBadToken      ; $EF
 .dw ErrBadToken      ; $F0
 .dw ErrBadToken      ; $F1
 .dw ErrBadToken      ; $F2
 .dw ErrBadToken      ; $F3
 .dw ErrBadToken      ; $F4
 .dw ErrBadToken      ; $F5
 .dw ErrBadToken      ; $F6
 .dw ErrBadToken      ; $F7
 .dw ErrBadToken      ; $F8
 .dw ErrBadToken      ; $F9
 .dw ErrBadToken      ; $FA
 .dw ErrBadToken      ; $FB
 .dw ErrBadToken      ; $FC
 .dw ErrBadToken      ; $FD
 .dw ErrBadToken      ; $FE
 .dw ErrBadToken      ; $FF
ExecLine_:
  ld a,(hl)
  inc hl
  call VarP
  ret nc
  push de
  push hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  call ParseNextFullArg_HL
  ld de,(parsePtr)
  pop hl
  inc de
  ld (hl),e
  inc hl
  ld (hl),d
  pop hl
  ld (parsePtr),hl
  ret
ExecLine:
  call ParseFullArg
  push bc
  cp 2Bh
  ld bc,(ProgStart)
  call z,ParseNextFullArg
  push bc
  ld bc,32768
  cp 2Bh
  call z,ParseNextFullArg
  push bc
  cp 2Bh
  ld bc,63
  call z,ParseNextFullArg
  ld a,c
  pop bc
  pop hl
  pop de
  call SearchLine
  ld b,d
  ld c,e
  jp g_expr
Byte:
  ld b,0
  ld c,(hl)
  inc hl
  ld (parsePtr),hl
  ret
Word:
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (parsePtr),hl
  ret
PowerOf2:
  call ParseFullArg
  ld a,c
  ld hl,0
  ld d,h
  ld e,h
  cp 32
  jr nc,Po2End
  inc l
  or a
  jr z,Po2End
  ld b,a
  add hl,hl
  rl e
  rl d
  djnz $-5
Po2End:
  ld b,h
  ld c,l
  ret

Base2Num:
  ld bc,0
  ld d,b
  ld e,c
Base2Loop:
  ld a,(hl)
  sub '2'
  add a,2
  jr nc,ExitBase2Loop
  rrca
  rl c
  rl b
  rl e
  rl d
  inc hl
  jp Base2Loop      ;It saves 2 cycles using JP D:
ExitBase2Loop:
  set FactorialFlag,(iy+InternalFlag)
  ld (parsePtr),hl
  ret
LnToken:
  ld a,(hl)
  cp $B0
  push bc
  jr z,JumpBack
  call ParseFullArg
  ld d,b \ ld e,c
  ld bc,0
_:
  ld a,3Fh
  cpir
  dec de
  ld a,d \ or e
  jr nz,-_
  ld (parsePtr),hl
  pop bc
  ret
JumpBack:
  call ParseNextFullArg
  ld d,b \ ld e,c
  dec hl
  ld bc,0
  inc de
  ld a,3Fh
  cpdr
  dec de
  ld a,d \ or e
  jr nz,$-7
  ld (parsePtr),hl
  pop bc
  ret
GetByte:
  ld d,3
  ld bc,-1
  xor a
  out (0),a
  in a,(0)
  xor d
  ret z
  ld bc,0800h
_:
  in a,(0)
  bit 1,a
  jr nz,-_
  out (0),a
  rra
  rl c
  djnz -_
  ret
SendByte:
;E is the byte to send
;BC is the wait length
  ld a,3
  out (0),a
  ld d,a
_:
  in a,(0)
  and d
  jr nz,+_
  dec bc
  ld a,b
  or c
  jr nz,-_
  dec bc
  ret
_:
  ld b,8
SendByteLoop:
;E is the byte to send
;D is the mask
  xor a
  rlc e
  jr c,$+3    ;could use rla
  inc a
  out (0),a
  djnz SendByteLoop
  xor a
  out (0),a
  ld c,a
  ret
cmdJmp:
#if (CommandJumpTable&255)=0
  ld h,CommandJumpTable>>8
  add a,a \ jr nc,$+3 \ inc h
  ld l,a
#else
  ld hl,CommandJumpTable
  add a,a \ jr nc,$+3 \ inc h
  add a,l \ ld l,a \ jr nc,$+3 \ inc h
#endif
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  push hl
  ld hl,(parsePtr)
  ret
menu:
  ld hl,(parsePtr)
  ld (TempWord1),hl
  ld hl,OP3
  ld (parsePtr),hl
  ld (hl),$E6
  inc hl
  ld (hl),0
  jp module
#include "progmeta.z80"
#include "module.z80"
#include "startmenu.z80"
#include "isort.z80"
#include "routines.z80"
#include "err.z80"
#include "data.z80"
.echo "Page 0: ",$8000-$," bytes remaining"

.fill $8000-$,255
#include "01.z80"
