#define ptrStack 8000h  ;255 bytes

t_While:
    ld hl,(parsePtr)
    call pushPtr
_:
    call parseArg
    ld a,b
    or c
    jp z,popPtr
    call parse
    call readPtr    ;read the last item on the ptrStack
    ld (parsePtr),hl
    jp -_
t_If:
    call parseArg
    ld a,b
    or c
    ret nz
;if there is no 'Then' token, skip the next line, else proceed as normal.

    ret
t_Then:
;This needs to push a parser instance so that the End can be processed.
;If BC=0, jump to the next appropriate Else, else continue as normal.
    ld a,b
    or c
    jp nz,parse
;need to seek 'End' (process) or 'Else' (don't process)

    ret
t_Else:
;skip over the block until an End is reached, but make sure to actually process the End.
    ret
t_End:
; should end this instance of the parser
    ret
pushPtr:
;pushes HL onto the pointer stack
;will error if the pointer stack exceeds 127 entries.
    push de
    push af
    ex de,hl
    ld hl,ptrStack
    ld a,(hl)
    add a,2
    jp c,err_stackOverflow
    ld (hl),a
    add a,l
    ld l,a
    jr nc,$+3
    inc h
    ld (hl),d
    dec hl
    ld (hl),e
    ex de,hl
    pop af
    pop de
    ret
readPtr:
;reads the last item on the pointer stack
    push af
    ld hl,ptrStack
    ld a,(hl)
    jr readptr_stepin
popPtr:
;pops an item off the poiner stack into HL
    push af
    ld hl,ptrStack
    ld a,(hl)
    sub 2
    jp c,err_stackUnderflow
    ld (hl),a
readptr_stepin:
    inc a
    add a,l
    ld l,a
    jr nc,$+3
    inc h
    ld a,(hl)
    inc hl
    ld h,(hl)
    ld l,a
    pop af
    ret

